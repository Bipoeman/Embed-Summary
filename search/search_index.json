{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Hell Embed Summary Web page Enter the midterm Summary","title":"Welcome to Hell Embed Summary Web page"},{"location":"#welcome-to-hell-embed-summary-web-page","text":"","title":"Welcome to Hell Embed Summary Web page"},{"location":"#enter-the-midterm-summary","text":"","title":"Enter the midterm Summary"},{"location":"midterm/","text":"Embeded System Midterm Chapter 1 : Embeded, MCU and ARM Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining Chapter 2 : Introducing to MBED \u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49) MBED Board Architecture LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } } Chapter 3 : Digital IO \u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a) \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs \u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49 7-Segment \u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 I = 5mA Vled = 1.8V Vpin = 3.3V Rinternal = 100\u03a9 \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a ((3.3 - 1.8) / 5m) - 100 = ___\u03a9 /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while } Control Larger Load \u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode Chapter 4 : Analog Output DAC (Digital to Analog Converter) Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22 PWM (Pulse Width Modulation) Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit PWM on MBED MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } } Servo Control \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32 Chapter 5 : Analog Input ADC (Analog to Digital Converter) Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error DAQ (Data Acquisition System) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System Sampling Frequency and Aliasing Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14 Analog Input with mbed LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } } Display Value to the computer \u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 Simple Analog sensor LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!! Chapter 7 Serial Communication \u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link SPI (Serial Peripheral Interface) Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2191 \u0e02\u0e36\u0e49\u0e19 3 1 \u2193 \u0e25\u0e07 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } } SPI on mbed : Slave Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49 I2C (Inter-Integrated Circuit) I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07 I2C on mbed MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32 Asynchronous Serial \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX) UART on mbed MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX) USB (Universal Serial Bus) \u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"Midterm"},{"location":"midterm/#embeded-system-midterm","text":"","title":"Embeded System Midterm"},{"location":"midterm/#chapter-1-embeded-mcu-and-arm","text":"Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining","title":"Chapter 1 : Embeded, MCU and ARM"},{"location":"midterm/#chapter-2-introducing-to-mbed","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49)","title":"Chapter 2 : Introducing to MBED"},{"location":"midterm/#mbed-board-architecture","text":"LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } }","title":"MBED Board Architecture"},{"location":"midterm/#chapter-3-digital-io","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a)","title":"Chapter 3 : Digital IO"},{"location":"midterm/#leds","text":"\u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs"},{"location":"midterm/#switch-input","text":"Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input"},{"location":"midterm/#7-segment","text":"\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 I = 5mA Vled = 1.8V Vpin = 3.3V Rinternal = 100\u03a9 \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a ((3.3 - 1.8) / 5m) - 100 = ___\u03a9 /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while }","title":"7-Segment"},{"location":"midterm/#control-larger-load","text":"\u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode","title":"Control Larger Load"},{"location":"midterm/#chapter-4-analog-output","text":"","title":"Chapter 4 : Analog Output"},{"location":"midterm/#dac-digital-to-analog-converter","text":"Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22","title":"DAC (Digital to Analog Converter)"},{"location":"midterm/#pwm-pulse-width-modulation","text":"Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit","title":"PWM (Pulse Width Modulation)"},{"location":"midterm/#pwm-on-mbed","text":"MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } }","title":"PWM on MBED"},{"location":"midterm/#servo-control","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32","title":"Servo Control"},{"location":"midterm/#chapter-5-analog-input","text":"","title":"Chapter 5 : Analog Input"},{"location":"midterm/#adc-analog-to-digital-converter","text":"Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error","title":"ADC (Analog to Digital Converter)"},{"location":"midterm/#daq-data-acquisition-system","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System","title":"DAQ (Data Acquisition System)"},{"location":"midterm/#sampling-frequency-and-aliasing","text":"Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14","title":"Sampling Frequency and Aliasing"},{"location":"midterm/#analog-input-with-mbed","text":"LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } }","title":"Analog Input with mbed"},{"location":"midterm/#display-value-to-the-computer","text":"\u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22","title":"Display Value to the computer"},{"location":"midterm/#simple-analog-sensor","text":"LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!!","title":"Simple Analog sensor"},{"location":"midterm/#chapter-7-serial-communication","text":"\u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link","title":"Chapter 7 Serial Communication"},{"location":"midterm/#spi-serial-peripheral-interface","text":"Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2191 \u0e02\u0e36\u0e49\u0e19 3 1 \u2193 \u0e25\u0e07 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } }","title":"SPI (Serial Peripheral Interface)"},{"location":"midterm/#spi-on-mbed-slave","text":"Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49","title":"SPI on mbed : Slave"},{"location":"midterm/#i2c-inter-integrated-circuit","text":"I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07","title":"I2C (Inter-Integrated Circuit)"},{"location":"midterm/#i2c-on-mbed","text":"MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32","title":"I2C on mbed"},{"location":"midterm/#asynchronous-serial","text":"\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX)","title":"Asynchronous Serial"},{"location":"midterm/#uart-on-mbed","text":"MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX)","title":"UART on mbed"},{"location":"midterm/#usb-universal-serial-bus","text":"\u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"USB (Universal Serial Bus)"}]}