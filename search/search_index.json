{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Hell Embed Summary Web page Enter the midterm Summary","title":"Home"},{"location":"#welcome-to-hell-embed-summary-web-page","text":"","title":"Welcome to Hell Embed Summary Web page"},{"location":"#enter-the-midterm-summary","text":"","title":"Enter the midterm Summary"},{"location":"interrupt/","text":"Chapter 9 Interrupts Timers and Tasks \u0e1b\u0e4d\u0e0d\u0e2b\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e1b\u0e31\u0e0d\u0e2b\u0e32 \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e17\u0e31\u0e28\u0e19\u0e04\u0e15\u0e34\u0e02\u0e2d\u0e07 \u0e21\u0e36\u0e07 \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e1b\u0e31\u0e0d\u0e2b\u0e32 - \u0e23\u0e38\u0e01\u0e01\u0e35\u0e49 Timer and Interrupts MCU \u0e15\u0e49\u0e2d\u0e07\u0e17\u0e33\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e44\u0e14\u0e49 \u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32 \u0e2a\u0e23\u0e49\u0e32\u0e07 time-based event (\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e14\u0e35\u0e22\u0e27 \u0e2b\u0e23\u0e37\u0e2d\u0e2b\u0e25\u0e32\u0e22\u0e04\u0e23\u0e31\u0e49\u0e07) \u0e15\u0e2d\u0e1a\u0e2a\u0e19\u0e2d\u0e07 \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e23\u0e27\u0e14\u0e40\u0e23\u0e47\u0e27 Tasks : Event-Triggered and Time-Triggered Event-Triggered \u0e40\u0e01\u0e34\u0e14\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 event \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e21\u0e32\u0e01\u0e23\u0e30\u0e15\u0e38\u0e49\u0e19 Time-Triggered \u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a periodic \u0e0b\u0e36\u0e48\u0e07\u0e16\u0e39\u0e01\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e42\u0e14\u0e22 MCU Polling \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e2d\u0e22\u0e44\u0e1b\u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e16\u0e32\u0e19\u0e30\u0e02\u0e2d\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e22\u0e46 Polling Diagram \u0e17\u0e33\u0e44\u0e21\u0e40\u0e1b\u0e47\u0e19\u0e1b\u0e31\u0e0d\u0e2b\u0e32 1. \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 Poll \u0e01\u0e47\u0e17\u0e33\u0e2d\u0e30\u0e44\u0e23\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 2. \u0e04\u0e27\u0e32\u0e21\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e19 Interrupt \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d interrupt \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 \u0e2b\u0e22\u0e38\u0e14 CPU \u0e44\u0e14\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e34\u0e14 event Interrupt Flowchart Simple Interrupt on the mbed \u0e1a\u0e2d\u0e23\u0e4c\u0e14 mbed \u0e43\u0e0a\u0e49 pin \u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 5 - 30 \u0e22\u0e01\u0e40\u0e27\u0e49\u0e19 19,20 \u0e40\u0e1b\u0e47\u0e19 Interrupt Function Usage InterruptIn(pin) \u0e2a\u0e23\u0e49\u0e32\u0e07 Object \u0e02\u0e2d\u0e07 Interrupt rise(ISR) \u0e43\u0e2b\u0e49 Interrupt trigger \u0e17\u0e35\u0e48\u0e02\u0e2d\u0e1a\u0e02\u0e32\u0e02\u0e35\u0e49\u0e19 \u0e1e\u0e23\u0e49\u0e2d\u0e21 Attach Interrupt Service Routine (ISR) (\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e21\u0e31\u0e19\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 event \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30) fall(ISR) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 rise \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32\u0e25\u0e07 mode \u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e17\u0e33\u0e44\u0e23\u0e44\u0e21\u0e48\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08 \u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14 #include \"mbed.h\" InterruptIn button(p5); //\u0e2a\u0e23\u0e49\u0e32\u0e07 object + \u0e01\u0e33\u0e2b\u0e19\u0e14 pin DigitalOut led(LED1); DigitalOut flash(LED4); void ISR1() { // \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e17\u0e35\u0e48\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 interrupt led = !led; } int main() { button.rise(&ISR1); // attach the address of the ISR //function to the interrupt rising edge while(1) { //continuous loop, ready to be interrupted flash = !flash; wait(0.25); } } Deeper into interrupt (\u0e02\u0e49\u0e2d\u0e14\u0e35 Interrupt) Prioritized \u0e1a\u0e32\u0e07 event \u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e46\u0e44\u0e14\u0e49 Masked \u0e40\u0e1b\u0e34\u0e14\u0e1b\u0e34\u0e14\u0e44\u0e14\u0e49 \u0e40\u0e1c\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32 Nested \u0e17\u0e33\u0e46\u0e2d\u0e22\u0e39\u0e48\u0e42\u0e14\u0e19\u0e41\u0e17\u0e23\u0e01\u0e08\u0e32\u0e01\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e1e\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e44\u0e14\u0e49 Location can be selected \u0e40\u0e25\u0e37\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e44\u0e27\u0e49\u0e43\u0e19 memory \u0e2a\u0e48\u0e27\u0e19\u0e44\u0e2b\u0e19 Delay between event occur and response is called latancy \u0e16\u0e49\u0e32 Interrupt \u0e23\u0e2d processor \u0e15\u0e2d\u0e1a \u0e40\u0e02\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Pending Interrupt Response in more detail Testing interrupt latency \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e19\u0e35\u0e49\u0e08\u0e30\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 Latency \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22\u0e42\u0e14\u0e22\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 \u0e01\u0e27\u0e48\u0e32 LED \u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 1 \u0e2b\u0e48\u0e32\u0e07\u0e08\u0e32\u0e01 input squarewave \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22 \u0e43\u0e19\u0e02\u0e13\u0e30\u0e17\u0e35\u0e48\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a LED \u0e43\u0e19 int main() #include \"mbed.h\" InterruptIn squarewave(p5); //Connect input square wave here DigitalOut led(p6); DigitalOut flash(LED4); void pulse() { //ISR sets external led high for fixed duration led = 1; wait(0.01); led = 0; } int main() { squarewave.rise(&pulse); // attach the address of the pulse function to // the rising edge while(1) { // interrupt will occur within this endless loop flash = !flash; wait(0.25); } } Interrupt from analog Inputs \u0e43\u0e0a\u0e49 Comparator \u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32 \\(V_-\\) \u0e40\u0e01\u0e34\u0e19 \\(V_+\\) Output \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 High \u0e04\u0e23\u0e31\u0e1a\u0e08\u0e1a\ud83d\ude1c Interrupt with analog The Digital Counter \u0e43\u0e0a\u0e49 Flip-Flop \u0e40\u0e1b\u0e47\u0e19 Counter \u0e42\u0e14\u0e22\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e01\u0e47\u0e02\u0e36\u0e49\u0e19\u0e01\u0e31\u0e1a\u0e08\u0e33\u0e19\u0e27\u0e19\u0e1a\u0e34\u0e15\u0e40\u0e0a\u0e48\u0e19 8 bit \u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 0-255 ( \\(0-(2^8-1)\\) ) \u0e41\u0e25\u0e30\u0e01\u0e47\u0e16\u0e49\u0e32\u0e15\u0e48\u0e2d\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Input \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 Clock \u0e21\u0e31\u0e19\u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a Clock \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e40\u0e1b\u0e47\u0e19 binary \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e14\u0e49, Preload \u0e44\u0e14\u0e49, \u0e08\u0e30 Reset \u0e40\u0e1b\u0e47\u0e19 0 \u0e01\u0e47\u0e44\u0e14\u0e49 Counting and Timing \u0e16\u0e49\u0e32 Clock Source \u0e02\u0e2d\u0e07 Counter \u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e04\u0e07\u0e17\u0e35\u0e48 Counter \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e08\u0e30\u0e01\u0e25\u0e32\u0e22\u0e40\u0e1b\u0e47\u0e19 Timer Ex. \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e16\u0e49\u0e32\u0e21\u0e35 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 1MHz (\u0e2d\u0e31\u0e19\u0e1a\u0e19) \u0e17\u0e38\u0e01 Clock Cycle \u0e17\u0e35\u0e48\u0e1c\u0e48\u0e32\u0e19\u0e44\u0e1b\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e48\u0e32\u0e43\u0e19 Counter \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e44\u0e1b 1 \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e04\u0e48\u0e32 Counter \u0e40\u0e19\u0e35\u0e49\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e19\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\u0e44\u0e14\u0e49 \u0e42\u0e14\u0e22 Counter \u0e41\u0e15\u0e48\u0e25\u0e30\u0e40\u0e25\u0e02\u0e01\u0e47\u0e08\u0e30\u0e21\u0e35\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32 1uS (1/1MHz) \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32 Counter \u0e21\u0e35\u0e04\u0e48\u0e32\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a 2000 \u0e01\u0e47\u0e41\u0e1b\u0e25\u0e27\u0e48\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e25\u0e49\u0e27 2000uS \u0e14\u0e39\u0e17\u0e23\u0e07\u0e25\u0e30\u0e23\u0e39\u0e1b\u0e44\u0e21\u0e48\u0e04\u0e48\u0e2d\u0e22\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48 \u0e41\u0e25\u0e30\u0e1e\u0e2d Counter \u0e21\u0e31\u0e19\u0e19\u0e31\u0e1a\u0e44\u0e1b\u0e08\u0e19\u0e2a\u0e38\u0e14\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e21\u0e31\u0e19 (aka Overflow) \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Interrupt \u0e02\u0e36\u0e49\u0e19\u0e41\u0e25\u0e49\u0e27\u0e01\u0e47\u0e08\u0e30 Reset \u0e04\u0e48\u0e32\u0e01\u0e25\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0 \u0e04\u0e38\u0e13\u0e2a\u0e21\u0e1a\u0e31\u0e15\u0e34\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e01\u0e33\u0e2b\u0e19\u0e14 event \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a synchronize \u0e01\u0e31\u0e19\u0e44\u0e14\u0e49 Timer Interrupt Event MBED Timer MBED \u0e21\u0e35 Timers Timer General Purpose 4 \u0e15\u0e31\u0e27 Repetitive Interrupt Timer System Tick Timer Timer \u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a Simple Timing application Timeout \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e2b\u0e21\u0e14\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e44\u0e27\u0e49 (\u0e41\u0e1a\u0e1a non-blocking) Ticker \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e17\u0e35\u0e48\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 Timer \u0e17\u0e33\u0e44\u0e14\u0e49\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49 Function Usage start Start Timer stop Stop Timer reset Reset timer to 0 read get passed time in seconds read_ms get passed time in milliseconds read_us get passed time in microseconds Simple timer application \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e01\u0e47 Start Timer -> \u0e1b\u0e23\u0e34\u0e49\u0e19 Hello World \u0e41\u0e25\u0e30 Stop Timer \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25(\u0e21\u0e31\u0e49\u0e07) #include \"mbed.h\" Timer t; // define Timer with name \u201ct\u201d Serial pc(USBTX, USBRX); int main() { t.start(); //start the timer pc.printf(\"Hello World!\\n\"); t.stop(); //stop the timer //print to pc pc.printf(\"The time taken was %f seconds\\n\", t.read()); } mbed Timeout \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | detach(ISR) |Detach the function| #include \"mbed.h\" Timeout Response; //create a Timeout, and name it \"Response\" DigitalIn button (p5); DigitalOut led1(LED1); //blinks in time with main while(1) loop DigitalOut led2(LED2); //set high fixed period after button press DigitalOut led3(LED3); //goes high when button is pressed void blink() { //this function is called at the end of the Timeout led2 = 1; wait(0.5); led2=0; } int main() { while(1) { if(button==1){ Response.attach(&blink,2.0); //attach blink function to Response //Timeout, to occur after 2 seconds led3=1; //shows button has been pressed } else { led3=0; } led1=!led1; wait(0.2); } } mbed Ticker \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | detach(ISR) |Detach the function| #include \"mbed.h\" void led_switch(void); // Prototype function Ticker time_up; //define a Ticker, with name \u201ctime_up\u201d DigitalOut myled(LED1); void led_switch(){ //the function that Ticker will call myled=!myled; } int main(){ time_up.attach(&led_switch, 0.2); //initialises the ticker while(1){ //sit in a loop doing nothing, waiting for //Ticker interrupt } } Real Time Clock RTC (Real time clock) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d\u0e19\u0e32\u0e2c\u0e34\u0e01\u0e32\u0e17\u0e35\u0e48\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e21\u0e32\u0e01 \u0e43\u0e0a\u0e49 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 32kHz Function Usage Time Get Current Time set_time Set Current Time mktime converts converts the time structure into a calender time value localtime Converts a timestamp to a tm structure ctime Converts a timestamp to a human-readable string strftime Converts a tm structure to a custom format human-readable string #include \"mbed.h\" InterruptIn button(p18); // Interrupt on digital pushbutton input p18 DigitalOut led1(LED1); // digital out to LED1 Timer debounce; // define debounce timer void toggle(void); // function prototype int main() { debounce.start(); button.rise(&toggle); // attach the address of the toggle } // function to the rising edge void toggle() { if (debounce.read_ms()>10) // only allow toggle if debounce timer led1=!led1; // has passed 10 ms debounce.reset(); // restart timer when the toggle is performed } Realtime Operating System (RTOS) \u0e21\u0e35 OS \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e2a\u0e23\u0e23\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23 \u0e41\u0e1a\u0e48\u0e07\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23\u0e01\u0e31\u0e19 \u0e23\u0e31\u0e19\u0e42\u0e04\u0e49\u0e14\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Task \u0e2b\u0e23\u0e37\u0e2d Threads \u0e42\u0e14\u0e22 RTOS \u0e17\u0e33 2 \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e2b\u0e25\u0e31\u0e01\u0e46 Decides which Program run for how long Provide Commu and Sync between tasks Control overall resource RTOS Scheduling RTOS \u0e22\u0e31\u0e07\u0e21\u0e35 Scheduler \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e27\u0e48\u0e32 Task \u0e44\u0e2b\u0e19\u0e23\u0e31\u0e19 \u0e41\u0e25\u0e30\u0e23\u0e31\u0e19\u0e19\u0e32\u0e19\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Ex. Round Robin Scheduler sync activity to clock tick \u0e41\u0e15\u0e48 Round robin \u0e08\u0e30 Switch \u0e17\u0e38\u0e01 Clock Tick \u0e44\u0e21\u0e48\u0e27\u0e48\u0e32 Task \u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e07 \u0e01\u0e47\u0e40\u0e25\u0e22\u0e44\u0e21\u0e48\u0e21\u0e35 Task Prioritization (\u0e41\u0e15\u0e48 scheduler \u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e21\u0e35\u0e19\u0e30)","title":"Chapter 9"},{"location":"interrupt/#chapter-9-interrupts-timers-and-tasks","text":"\u0e1b\u0e4d\u0e0d\u0e2b\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e1b\u0e31\u0e0d\u0e2b\u0e32 \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e17\u0e31\u0e28\u0e19\u0e04\u0e15\u0e34\u0e02\u0e2d\u0e07 \u0e21\u0e36\u0e07 \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e1b\u0e31\u0e0d\u0e2b\u0e32 - \u0e23\u0e38\u0e01\u0e01\u0e35\u0e49","title":"Chapter 9 Interrupts Timers and Tasks"},{"location":"interrupt/#timer-and-interrupts","text":"","title":"Timer and Interrupts"},{"location":"interrupt/#mcu","text":"\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32 \u0e2a\u0e23\u0e49\u0e32\u0e07 time-based event (\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e14\u0e35\u0e22\u0e27 \u0e2b\u0e23\u0e37\u0e2d\u0e2b\u0e25\u0e32\u0e22\u0e04\u0e23\u0e31\u0e49\u0e07) \u0e15\u0e2d\u0e1a\u0e2a\u0e19\u0e2d\u0e07 \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e23\u0e27\u0e14\u0e40\u0e23\u0e47\u0e27","title":"MCU \u0e15\u0e49\u0e2d\u0e07\u0e17\u0e33\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e44\u0e14\u0e49"},{"location":"interrupt/#tasks-event-triggered-and-time-triggered","text":"","title":"Tasks : Event-Triggered and Time-Triggered"},{"location":"interrupt/#event-triggered","text":"\u0e40\u0e01\u0e34\u0e14\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 event \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e21\u0e32\u0e01\u0e23\u0e30\u0e15\u0e38\u0e49\u0e19","title":"Event-Triggered"},{"location":"interrupt/#time-triggered","text":"\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a periodic \u0e0b\u0e36\u0e48\u0e07\u0e16\u0e39\u0e01\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e42\u0e14\u0e22 MCU","title":"Time-Triggered"},{"location":"interrupt/#polling","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e2d\u0e22\u0e44\u0e1b\u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e16\u0e32\u0e19\u0e30\u0e02\u0e2d\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e22\u0e46 Polling Diagram","title":"Polling"},{"location":"interrupt/#_1","text":"","title":"\u0e17\u0e33\u0e44\u0e21\u0e40\u0e1b\u0e47\u0e19\u0e1b\u0e31\u0e0d\u0e2b\u0e32"},{"location":"interrupt/#1-poll","text":"","title":"1. \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 Poll \u0e01\u0e47\u0e17\u0e33\u0e2d\u0e30\u0e44\u0e23\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49"},{"location":"interrupt/#2","text":"","title":"2. \u0e04\u0e27\u0e32\u0e21\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e19"},{"location":"interrupt/#interrupt","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d interrupt \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 \u0e2b\u0e22\u0e38\u0e14 CPU \u0e44\u0e14\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e34\u0e14 event Interrupt Flowchart","title":"Interrupt"},{"location":"interrupt/#simple-interrupt-on-the-mbed","text":"\u0e1a\u0e2d\u0e23\u0e4c\u0e14 mbed \u0e43\u0e0a\u0e49 pin \u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 5 - 30 \u0e22\u0e01\u0e40\u0e27\u0e49\u0e19 19,20 \u0e40\u0e1b\u0e47\u0e19 Interrupt Function Usage InterruptIn(pin) \u0e2a\u0e23\u0e49\u0e32\u0e07 Object \u0e02\u0e2d\u0e07 Interrupt rise(ISR) \u0e43\u0e2b\u0e49 Interrupt trigger \u0e17\u0e35\u0e48\u0e02\u0e2d\u0e1a\u0e02\u0e32\u0e02\u0e35\u0e49\u0e19 \u0e1e\u0e23\u0e49\u0e2d\u0e21 Attach Interrupt Service Routine (ISR) (\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e21\u0e31\u0e19\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 event \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30) fall(ISR) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 rise \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32\u0e25\u0e07 mode \u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e17\u0e33\u0e44\u0e23\u0e44\u0e21\u0e48\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08","title":"Simple Interrupt on the mbed"},{"location":"interrupt/#_2","text":"#include \"mbed.h\" InterruptIn button(p5); //\u0e2a\u0e23\u0e49\u0e32\u0e07 object + \u0e01\u0e33\u0e2b\u0e19\u0e14 pin DigitalOut led(LED1); DigitalOut flash(LED4); void ISR1() { // \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e17\u0e35\u0e48\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 interrupt led = !led; } int main() { button.rise(&ISR1); // attach the address of the ISR //function to the interrupt rising edge while(1) { //continuous loop, ready to be interrupted flash = !flash; wait(0.25); } }","title":"\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14"},{"location":"interrupt/#deeper-into-interrupt-interrupt","text":"Prioritized \u0e1a\u0e32\u0e07 event \u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e46\u0e44\u0e14\u0e49 Masked \u0e40\u0e1b\u0e34\u0e14\u0e1b\u0e34\u0e14\u0e44\u0e14\u0e49 \u0e40\u0e1c\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32 Nested \u0e17\u0e33\u0e46\u0e2d\u0e22\u0e39\u0e48\u0e42\u0e14\u0e19\u0e41\u0e17\u0e23\u0e01\u0e08\u0e32\u0e01\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e1e\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e44\u0e14\u0e49 Location can be selected \u0e40\u0e25\u0e37\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e44\u0e27\u0e49\u0e43\u0e19 memory \u0e2a\u0e48\u0e27\u0e19\u0e44\u0e2b\u0e19 Delay between event occur and response is called latancy \u0e16\u0e49\u0e32 Interrupt \u0e23\u0e2d processor \u0e15\u0e2d\u0e1a \u0e40\u0e02\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Pending Interrupt Response in more detail","title":"Deeper into interrupt (\u0e02\u0e49\u0e2d\u0e14\u0e35 Interrupt)"},{"location":"interrupt/#testing-interrupt-latency","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e19\u0e35\u0e49\u0e08\u0e30\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 Latency \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22\u0e42\u0e14\u0e22\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 \u0e01\u0e27\u0e48\u0e32 LED \u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 1 \u0e2b\u0e48\u0e32\u0e07\u0e08\u0e32\u0e01 input squarewave \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22 \u0e43\u0e19\u0e02\u0e13\u0e30\u0e17\u0e35\u0e48\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a LED \u0e43\u0e19 int main() #include \"mbed.h\" InterruptIn squarewave(p5); //Connect input square wave here DigitalOut led(p6); DigitalOut flash(LED4); void pulse() { //ISR sets external led high for fixed duration led = 1; wait(0.01); led = 0; } int main() { squarewave.rise(&pulse); // attach the address of the pulse function to // the rising edge while(1) { // interrupt will occur within this endless loop flash = !flash; wait(0.25); } }","title":"Testing interrupt latency"},{"location":"interrupt/#interrupt-from-analog-inputs","text":"\u0e43\u0e0a\u0e49 Comparator \u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32 \\(V_-\\) \u0e40\u0e01\u0e34\u0e19 \\(V_+\\) Output \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 High \u0e04\u0e23\u0e31\u0e1a\u0e08\u0e1a\ud83d\ude1c Interrupt with analog","title":"Interrupt from analog Inputs"},{"location":"interrupt/#the-digital-counter","text":"\u0e43\u0e0a\u0e49 Flip-Flop \u0e40\u0e1b\u0e47\u0e19 Counter \u0e42\u0e14\u0e22\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e01\u0e47\u0e02\u0e36\u0e49\u0e19\u0e01\u0e31\u0e1a\u0e08\u0e33\u0e19\u0e27\u0e19\u0e1a\u0e34\u0e15\u0e40\u0e0a\u0e48\u0e19 8 bit \u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 0-255 ( \\(0-(2^8-1)\\) ) \u0e41\u0e25\u0e30\u0e01\u0e47\u0e16\u0e49\u0e32\u0e15\u0e48\u0e2d\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Input \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 Clock \u0e21\u0e31\u0e19\u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a Clock \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e40\u0e1b\u0e47\u0e19 binary \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e14\u0e49, Preload \u0e44\u0e14\u0e49, \u0e08\u0e30 Reset \u0e40\u0e1b\u0e47\u0e19 0 \u0e01\u0e47\u0e44\u0e14\u0e49","title":"The Digital Counter"},{"location":"interrupt/#counting-and-timing","text":"\u0e16\u0e49\u0e32 Clock Source \u0e02\u0e2d\u0e07 Counter \u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e04\u0e07\u0e17\u0e35\u0e48 Counter \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e08\u0e30\u0e01\u0e25\u0e32\u0e22\u0e40\u0e1b\u0e47\u0e19 Timer Ex. \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e16\u0e49\u0e32\u0e21\u0e35 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 1MHz (\u0e2d\u0e31\u0e19\u0e1a\u0e19) \u0e17\u0e38\u0e01 Clock Cycle \u0e17\u0e35\u0e48\u0e1c\u0e48\u0e32\u0e19\u0e44\u0e1b\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e48\u0e32\u0e43\u0e19 Counter \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e44\u0e1b 1 \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e04\u0e48\u0e32 Counter \u0e40\u0e19\u0e35\u0e49\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e19\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\u0e44\u0e14\u0e49 \u0e42\u0e14\u0e22 Counter \u0e41\u0e15\u0e48\u0e25\u0e30\u0e40\u0e25\u0e02\u0e01\u0e47\u0e08\u0e30\u0e21\u0e35\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32 1uS (1/1MHz) \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32 Counter \u0e21\u0e35\u0e04\u0e48\u0e32\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a 2000 \u0e01\u0e47\u0e41\u0e1b\u0e25\u0e27\u0e48\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e25\u0e49\u0e27 2000uS \u0e14\u0e39\u0e17\u0e23\u0e07\u0e25\u0e30\u0e23\u0e39\u0e1b\u0e44\u0e21\u0e48\u0e04\u0e48\u0e2d\u0e22\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48 \u0e41\u0e25\u0e30\u0e1e\u0e2d Counter \u0e21\u0e31\u0e19\u0e19\u0e31\u0e1a\u0e44\u0e1b\u0e08\u0e19\u0e2a\u0e38\u0e14\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e21\u0e31\u0e19 (aka Overflow) \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Interrupt \u0e02\u0e36\u0e49\u0e19\u0e41\u0e25\u0e49\u0e27\u0e01\u0e47\u0e08\u0e30 Reset \u0e04\u0e48\u0e32\u0e01\u0e25\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0 \u0e04\u0e38\u0e13\u0e2a\u0e21\u0e1a\u0e31\u0e15\u0e34\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e01\u0e33\u0e2b\u0e19\u0e14 event \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a synchronize \u0e01\u0e31\u0e19\u0e44\u0e14\u0e49 Timer Interrupt Event","title":"Counting and Timing"},{"location":"interrupt/#mbed-timer","text":"","title":"MBED Timer"},{"location":"interrupt/#mbed-timers","text":"Timer General Purpose 4 \u0e15\u0e31\u0e27 Repetitive Interrupt Timer System Tick Timer Timer \u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a Simple Timing application Timeout \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e2b\u0e21\u0e14\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e44\u0e27\u0e49 (\u0e41\u0e1a\u0e1a non-blocking) Ticker \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e17\u0e35\u0e48\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14","title":"MBED \u0e21\u0e35 Timers"},{"location":"interrupt/#timer","text":"Function Usage start Start Timer stop Stop Timer reset Reset timer to 0 read get passed time in seconds read_ms get passed time in milliseconds read_us get passed time in microseconds","title":"Timer \u0e17\u0e33\u0e44\u0e14\u0e49\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49"},{"location":"interrupt/#simple-timer-application","text":"\u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e01\u0e47 Start Timer -> \u0e1b\u0e23\u0e34\u0e49\u0e19 Hello World \u0e41\u0e25\u0e30 Stop Timer \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25(\u0e21\u0e31\u0e49\u0e07) #include \"mbed.h\" Timer t; // define Timer with name \u201ct\u201d Serial pc(USBTX, USBRX); int main() { t.start(); //start the timer pc.printf(\"Hello World!\\n\"); t.stop(); //stop the timer //print to pc pc.printf(\"The time taken was %f seconds\\n\", t.read()); }","title":"Simple timer application"},{"location":"interrupt/#mbed-timeout","text":"\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | detach(ISR) |Detach the function| #include \"mbed.h\" Timeout Response; //create a Timeout, and name it \"Response\" DigitalIn button (p5); DigitalOut led1(LED1); //blinks in time with main while(1) loop DigitalOut led2(LED2); //set high fixed period after button press DigitalOut led3(LED3); //goes high when button is pressed void blink() { //this function is called at the end of the Timeout led2 = 1; wait(0.5); led2=0; } int main() { while(1) { if(button==1){ Response.attach(&blink,2.0); //attach blink function to Response //Timeout, to occur after 2 seconds led3=1; //shows button has been pressed } else { led3=0; } led1=!led1; wait(0.2); } }","title":"mbed Timeout"},{"location":"interrupt/#mbed-ticker","text":"\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | detach(ISR) |Detach the function| #include \"mbed.h\" void led_switch(void); // Prototype function Ticker time_up; //define a Ticker, with name \u201ctime_up\u201d DigitalOut myled(LED1); void led_switch(){ //the function that Ticker will call myled=!myled; } int main(){ time_up.attach(&led_switch, 0.2); //initialises the ticker while(1){ //sit in a loop doing nothing, waiting for //Ticker interrupt } }","title":"mbed Ticker"},{"location":"interrupt/#real-time-clock","text":"RTC (Real time clock) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d\u0e19\u0e32\u0e2c\u0e34\u0e01\u0e32\u0e17\u0e35\u0e48\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e21\u0e32\u0e01 \u0e43\u0e0a\u0e49 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 32kHz Function Usage Time Get Current Time set_time Set Current Time mktime converts converts the time structure into a calender time value localtime Converts a timestamp to a tm structure ctime Converts a timestamp to a human-readable string strftime Converts a tm structure to a custom format human-readable string #include \"mbed.h\" InterruptIn button(p18); // Interrupt on digital pushbutton input p18 DigitalOut led1(LED1); // digital out to LED1 Timer debounce; // define debounce timer void toggle(void); // function prototype int main() { debounce.start(); button.rise(&toggle); // attach the address of the toggle } // function to the rising edge void toggle() { if (debounce.read_ms()>10) // only allow toggle if debounce timer led1=!led1; // has passed 10 ms debounce.reset(); // restart timer when the toggle is performed }","title":"Real Time Clock"},{"location":"interrupt/#realtime-operating-system-rtos","text":"\u0e21\u0e35 OS \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e2a\u0e23\u0e23\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23 \u0e41\u0e1a\u0e48\u0e07\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23\u0e01\u0e31\u0e19 \u0e23\u0e31\u0e19\u0e42\u0e04\u0e49\u0e14\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Task \u0e2b\u0e23\u0e37\u0e2d Threads \u0e42\u0e14\u0e22 RTOS \u0e17\u0e33 2 \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e2b\u0e25\u0e31\u0e01\u0e46 Decides which Program run for how long Provide Commu and Sync between tasks Control overall resource","title":"Realtime Operating System (RTOS)"},{"location":"interrupt/#rtos-scheduling","text":"RTOS \u0e22\u0e31\u0e07\u0e21\u0e35 Scheduler \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e27\u0e48\u0e32 Task \u0e44\u0e2b\u0e19\u0e23\u0e31\u0e19 \u0e41\u0e25\u0e30\u0e23\u0e31\u0e19\u0e19\u0e32\u0e19\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Ex. Round Robin Scheduler sync activity to clock tick \u0e41\u0e15\u0e48 Round robin \u0e08\u0e30 Switch \u0e17\u0e38\u0e01 Clock Tick \u0e44\u0e21\u0e48\u0e27\u0e48\u0e32 Task \u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e07 \u0e01\u0e47\u0e40\u0e25\u0e22\u0e44\u0e21\u0e48\u0e21\u0e35 Task Prioritization (\u0e41\u0e15\u0e48 scheduler \u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e21\u0e35\u0e19\u0e30)","title":"RTOS Scheduling"},{"location":"midterm/","text":"Embeded System Midterm Chapter 1 : Embeded, MCU and ARM Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining Chapter 2 : Introducing to MBED \u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49) MBED Board Architecture LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } } Chapter 3 : Digital IO \u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a) \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs \u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49 7-Segment \u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 \\(I = 4mA\\) \\(V_{led} = 1.8V\\) \\(V_{pin} = 3.3V\\) \\(R_{internal} = 100\u03a9\\) \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3 - 1.8}{4m} - 100 = 275\u03a9\\) /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while } Control Larger Load \u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode Chapter 4 : Analog Output DAC (Digital to Analog Converter) Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22 PWM (Pulse Width Modulation) Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit PWM on MBED MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } } Servo Control \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32 Chapter 5 : Analog Input ADC (Analog to Digital Converter) Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error DAQ (Data Acquisition System) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System Sampling Frequency and Aliasing Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14 Analog Input with mbed LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } } Display Value to the computer \u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 Simple Analog sensor LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!! Chapter 7 Serial Communication \u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link SPI (Serial Peripheral Interface) Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2193 \u0e25\u0e07 3 1 \u2191 \u0e02\u0e36\u0e49\u0e19 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } } SPI on mbed : Slave Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49 I2C (Inter-Integrated Circuit) I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07 I2C on mbed MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32 Asynchronous Serial \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX) UART on mbed MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX) USB (Universal Serial Bus) \u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"Midterm"},{"location":"midterm/#embeded-system-midterm","text":"","title":"Embeded System Midterm"},{"location":"midterm/#chapter-1-embeded-mcu-and-arm","text":"Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining","title":"Chapter 1 : Embeded, MCU and ARM"},{"location":"midterm/#chapter-2-introducing-to-mbed","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49)","title":"Chapter 2 : Introducing to MBED"},{"location":"midterm/#mbed-board-architecture","text":"LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } }","title":"MBED Board Architecture"},{"location":"midterm/#chapter-3-digital-io","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a)","title":"Chapter 3 : Digital IO"},{"location":"midterm/#leds","text":"\u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs"},{"location":"midterm/#switch-input","text":"Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input"},{"location":"midterm/#7-segment","text":"\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 \\(I = 4mA\\) \\(V_{led} = 1.8V\\) \\(V_{pin} = 3.3V\\) \\(R_{internal} = 100\u03a9\\) \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3 - 1.8}{4m} - 100 = 275\u03a9\\) /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while }","title":"7-Segment"},{"location":"midterm/#control-larger-load","text":"\u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode","title":"Control Larger Load"},{"location":"midterm/#chapter-4-analog-output","text":"","title":"Chapter 4 : Analog Output"},{"location":"midterm/#dac-digital-to-analog-converter","text":"Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22","title":"DAC (Digital to Analog Converter)"},{"location":"midterm/#pwm-pulse-width-modulation","text":"Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit","title":"PWM (Pulse Width Modulation)"},{"location":"midterm/#pwm-on-mbed","text":"MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } }","title":"PWM on MBED"},{"location":"midterm/#servo-control","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32","title":"Servo Control"},{"location":"midterm/#chapter-5-analog-input","text":"","title":"Chapter 5 : Analog Input"},{"location":"midterm/#adc-analog-to-digital-converter","text":"Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error","title":"ADC (Analog to Digital Converter)"},{"location":"midterm/#daq-data-acquisition-system","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System","title":"DAQ (Data Acquisition System)"},{"location":"midterm/#sampling-frequency-and-aliasing","text":"Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14","title":"Sampling Frequency and Aliasing"},{"location":"midterm/#analog-input-with-mbed","text":"LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } }","title":"Analog Input with mbed"},{"location":"midterm/#display-value-to-the-computer","text":"\u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22","title":"Display Value to the computer"},{"location":"midterm/#simple-analog-sensor","text":"LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!!","title":"Simple Analog sensor"},{"location":"midterm/#chapter-7-serial-communication","text":"\u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link","title":"Chapter 7 Serial Communication"},{"location":"midterm/#spi-serial-peripheral-interface","text":"Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2193 \u0e25\u0e07 3 1 \u2191 \u0e02\u0e36\u0e49\u0e19 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } }","title":"SPI (Serial Peripheral Interface)"},{"location":"midterm/#spi-on-mbed-slave","text":"Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49","title":"SPI on mbed : Slave"},{"location":"midterm/#i2c-inter-integrated-circuit","text":"I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07","title":"I2C (Inter-Integrated Circuit)"},{"location":"midterm/#i2c-on-mbed","text":"MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32","title":"I2C on mbed"},{"location":"midterm/#asynchronous-serial","text":"\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX)","title":"Asynchronous Serial"},{"location":"midterm/#uart-on-mbed","text":"MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX)","title":"UART on mbed"},{"location":"midterm/#usb-universal-serial-bus","text":"\u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"USB (Universal Serial Bus)"}]}