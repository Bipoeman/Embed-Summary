{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Hell Embed Summary Web page Enter the midterm Summary","title":"Welcome to Hell Embed Summary Web page"},{"location":"#welcome-to-hell-embed-summary-web-page","text":"","title":"Welcome to Hell Embed Summary Web page"},{"location":"#enter-the-midterm-summary","text":"","title":"Enter the midterm Summary"},{"location":"internet/","text":"Chapter 12 Internet Communication and Controls Introducing The Internet \u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e2a\u0e48\u0e27\u0e19\u0e19\u0e35\u0e49\u0e21\u0e35\u0e41\u0e04\u0e48\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c Embed \u0e01\u0e47\u0e43\u0e0a\u0e49 Internet \u0e44\u0e14\u0e49\u0e19\u0e30 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 IOT (Internet of things) The Ethernet \u0e43\u0e0a\u0e49\u0e21\u0e32\u0e15\u0e23\u0e10\u0e32\u0e19 IEEE 802.3 \u0e17\u0e35\u0e48\u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e1a\u0e22\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\u0e44\u0e14\u0e49\u0e16\u0e36\u0e07 100Gbps (\u0e44\u0e14\u0e49\u0e41\u0e04\u0e48\u0e43\u0e19\u0e08\u0e34\u0e19\u0e15\u0e19\u0e32\u0e01\u0e32\u0e23\u0e41\u0e2b\u0e25\u0e30) \u0e40\u0e1b\u0e47\u0e19 Protocol \u0e41\u0e1a\u0e1a Serial \u0e42\u0e14\u0e22\u0e08\u0e30\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Network \u0e17\u0e35\u0e48\u0e41\u0e1a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d LAN \u0e23\u0e30\u0e22\u0e30\u0e43\u0e01\u0e25\u0e49\u0e46\u0e40\u0e0a\u0e48\u0e19\u0e43\u0e19\u0e15\u0e36\u0e01 \u0e2d\u0e32\u0e08\u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35\u0e40\u0e19\u0e47\u0e15\u0e01\u0e47\u0e44\u0e14\u0e49 WAN \u0e23\u0e30\u0e22\u0e30\u0e44\u0e01\u0e25\u0e02\u0e36\u0e49\u0e19 \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19\u0e21\u0e35\u0e40\u0e19\u0e47\u0e15 \u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e15\u0e48\u0e2d 4 \u0e40\u0e2a\u0e49\u0e19 \u0e42\u0e14\u0e22\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e41\u0e1a\u0e1a Differential \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e25\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 TX+,TX- \u0e41\u0e25\u0e30 RX+,RX- Ethernet \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e40\u0e1b\u0e47\u0e19 Frame \u0e42\u0e14\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e40\u0e23\u0e47\u0e27\u0e41\u0e25\u0e30\u0e43\u0e2b\u0e0d\u0e48 \u0e41\u0e15\u0e48\u0e25\u0e30 Frame \u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 MAC Address \u0e02\u0e2d\u0e07\u0e15\u0e49\u0e19\u0e17\u0e32\u0e07\u0e41\u0e25\u0e30\u0e1b\u0e25\u0e32\u0e22\u0e17\u0e32\u0e07 Ethernet Frame \u0e1c\u0e21\u0e44\u0e21\u0e48\u0e08\u0e33\u0e04\u0e23\u0e31\u0e1a Ethernet \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e42\u0e14\u0e22 Encode \u0e41\u0e1a\u0e1a Manchester \u0e01\u0e47\u0e04\u0e37\u0e2d High->Low \u0e19\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0, Low->High \u0e19\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 1 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e21\u0e31\u0e19\u0e14\u0e39\u0e22\u0e31\u0e07\u0e44\u0e07\u0e41\u0e15\u0e48\u0e21\u0e31\u0e19\u0e43\u0e0a\u0e49 Sync Clock \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 Ethernet on mbed /* Program Example 12.7: Ethernet write - sends two data bytes every 200 ms from an mbed\u2019s Ethernet port. The two byte values are arbitrarily chosen as 0xB9 and 0x46. */ #include \"mbed.h\" #include \"Ethernet.h\" Ethernet eth; // The Ethernet object char data[]={0xB9,0x46}; // Define the data values int main() { while (1) { eth.write(data,0x02); // Write the package eth.send(); // Send the package wait(0.2); // wait 200 ms } } /* Program Example 12.8: Ethernet read - allows an mbed to read Ethernet data traffic and display the captured data to the screen */ #include \"mbed.h\" Ethernet eth; // Ethernet object Serial pc(USBTX, USBRX); // tx, rx for host terminal coms char buf[0xFF]; // create a large buffer to store data int main() { pc.printf(\"Ethernet data read and display\\n\\r\"); while (1) { int size = eth.receive(); // get size of incoming data packet if (size > 0) { // if packet received eth.read(buf, size); // read packet to data buffer pc.printf(\"size = %d data = \",size); // print to screen for (int i=0;i<size;i++) { // loop for each data byte pc.printf(\"%02X \",buf[i]); // print data to screen, %X hexadecimal } pc.printf(\"\\n\\r\"); } } } Ethernet Frame \u0e2d\u0e31\u0e19\u0e1a\u0e19\u0e42\u0e04\u0e49\u0e14\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e2d\u0e31\u0e19\u0e25\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14\u0e23\u0e31\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e2a\u0e48\u0e27\u0e19\u0e23\u0e39\u0e1b\u0e41\u0e2a\u0e14\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d\u0e2a\u0e32\u0e22 \u0e08\u0e1a LAN on MBED HTTP on MBED WAN on MBED The IOT (Internet of things)","title":"Chapter 12"},{"location":"internet/#chapter-12-internet-communication-and-controls","text":"","title":"Chapter 12 Internet Communication and Controls"},{"location":"internet/#introducing","text":"","title":"Introducing"},{"location":"internet/#the-internet","text":"\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e2a\u0e48\u0e27\u0e19\u0e19\u0e35\u0e49\u0e21\u0e35\u0e41\u0e04\u0e48\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c Embed \u0e01\u0e47\u0e43\u0e0a\u0e49 Internet \u0e44\u0e14\u0e49\u0e19\u0e30 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 IOT (Internet of things)","title":"The Internet"},{"location":"internet/#the-ethernet","text":"\u0e43\u0e0a\u0e49\u0e21\u0e32\u0e15\u0e23\u0e10\u0e32\u0e19 IEEE 802.3 \u0e17\u0e35\u0e48\u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e1a\u0e22\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\u0e44\u0e14\u0e49\u0e16\u0e36\u0e07 100Gbps (\u0e44\u0e14\u0e49\u0e41\u0e04\u0e48\u0e43\u0e19\u0e08\u0e34\u0e19\u0e15\u0e19\u0e32\u0e01\u0e32\u0e23\u0e41\u0e2b\u0e25\u0e30) \u0e40\u0e1b\u0e47\u0e19 Protocol \u0e41\u0e1a\u0e1a Serial \u0e42\u0e14\u0e22\u0e08\u0e30\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Network \u0e17\u0e35\u0e48\u0e41\u0e1a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d LAN \u0e23\u0e30\u0e22\u0e30\u0e43\u0e01\u0e25\u0e49\u0e46\u0e40\u0e0a\u0e48\u0e19\u0e43\u0e19\u0e15\u0e36\u0e01 \u0e2d\u0e32\u0e08\u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35\u0e40\u0e19\u0e47\u0e15\u0e01\u0e47\u0e44\u0e14\u0e49 WAN \u0e23\u0e30\u0e22\u0e30\u0e44\u0e01\u0e25\u0e02\u0e36\u0e49\u0e19 \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19\u0e21\u0e35\u0e40\u0e19\u0e47\u0e15 \u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e15\u0e48\u0e2d 4 \u0e40\u0e2a\u0e49\u0e19 \u0e42\u0e14\u0e22\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e41\u0e1a\u0e1a Differential \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e25\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 TX+,TX- \u0e41\u0e25\u0e30 RX+,RX- Ethernet \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e40\u0e1b\u0e47\u0e19 Frame \u0e42\u0e14\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e40\u0e23\u0e47\u0e27\u0e41\u0e25\u0e30\u0e43\u0e2b\u0e0d\u0e48 \u0e41\u0e15\u0e48\u0e25\u0e30 Frame \u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 MAC Address \u0e02\u0e2d\u0e07\u0e15\u0e49\u0e19\u0e17\u0e32\u0e07\u0e41\u0e25\u0e30\u0e1b\u0e25\u0e32\u0e22\u0e17\u0e32\u0e07 Ethernet Frame \u0e1c\u0e21\u0e44\u0e21\u0e48\u0e08\u0e33\u0e04\u0e23\u0e31\u0e1a Ethernet \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e42\u0e14\u0e22 Encode \u0e41\u0e1a\u0e1a Manchester \u0e01\u0e47\u0e04\u0e37\u0e2d High->Low \u0e19\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0, Low->High \u0e19\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 1 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e21\u0e31\u0e19\u0e14\u0e39\u0e22\u0e31\u0e07\u0e44\u0e07\u0e41\u0e15\u0e48\u0e21\u0e31\u0e19\u0e43\u0e0a\u0e49 Sync Clock \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22","title":"The Ethernet"},{"location":"internet/#ethernet-on-mbed","text":"/* Program Example 12.7: Ethernet write - sends two data bytes every 200 ms from an mbed\u2019s Ethernet port. The two byte values are arbitrarily chosen as 0xB9 and 0x46. */ #include \"mbed.h\" #include \"Ethernet.h\" Ethernet eth; // The Ethernet object char data[]={0xB9,0x46}; // Define the data values int main() { while (1) { eth.write(data,0x02); // Write the package eth.send(); // Send the package wait(0.2); // wait 200 ms } } /* Program Example 12.8: Ethernet read - allows an mbed to read Ethernet data traffic and display the captured data to the screen */ #include \"mbed.h\" Ethernet eth; // Ethernet object Serial pc(USBTX, USBRX); // tx, rx for host terminal coms char buf[0xFF]; // create a large buffer to store data int main() { pc.printf(\"Ethernet data read and display\\n\\r\"); while (1) { int size = eth.receive(); // get size of incoming data packet if (size > 0) { // if packet received eth.read(buf, size); // read packet to data buffer pc.printf(\"size = %d data = \",size); // print to screen for (int i=0;i<size;i++) { // loop for each data byte pc.printf(\"%02X \",buf[i]); // print data to screen, %X hexadecimal } pc.printf(\"\\n\\r\"); } } } Ethernet Frame \u0e2d\u0e31\u0e19\u0e1a\u0e19\u0e42\u0e04\u0e49\u0e14\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e2d\u0e31\u0e19\u0e25\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14\u0e23\u0e31\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e2a\u0e48\u0e27\u0e19\u0e23\u0e39\u0e1b\u0e41\u0e2a\u0e14\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d\u0e2a\u0e32\u0e22 \u0e08\u0e1a","title":"Ethernet on mbed"},{"location":"internet/#lan-on-mbed","text":"","title":"LAN on MBED"},{"location":"internet/#http-on-mbed","text":"","title":"HTTP on MBED"},{"location":"internet/#wan-on-mbed","text":"","title":"WAN on MBED"},{"location":"internet/#the-iot-internet-of-things","text":"","title":"The IOT (Internet of things)"},{"location":"interrupt/","text":"Chapter 9 Interrupts Timers and Tasks \u0e1b\u0e4d\u0e0d\u0e2b\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e1b\u0e31\u0e0d\u0e2b\u0e32 \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e17\u0e31\u0e28\u0e19\u0e04\u0e15\u0e34\u0e02\u0e2d\u0e07 \u0e21\u0e36\u0e07 \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e1b\u0e31\u0e0d\u0e2b\u0e32 - \u0e23\u0e38\u0e01\u0e01\u0e35\u0e49 Timer and Interrupts MCU \u0e15\u0e49\u0e2d\u0e07\u0e17\u0e33\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e44\u0e14\u0e49 \u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32 \u0e2a\u0e23\u0e49\u0e32\u0e07 time-based event (\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e14\u0e35\u0e22\u0e27 \u0e2b\u0e23\u0e37\u0e2d\u0e2b\u0e25\u0e32\u0e22\u0e04\u0e23\u0e31\u0e49\u0e07) \u0e15\u0e2d\u0e1a\u0e2a\u0e19\u0e2d\u0e07 \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e23\u0e27\u0e14\u0e40\u0e23\u0e47\u0e27 Tasks : Event-Triggered and Time-Triggered Event-Triggered \u0e40\u0e01\u0e34\u0e14\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 event \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e21\u0e32\u0e01\u0e23\u0e30\u0e15\u0e38\u0e49\u0e19 Time-Triggered \u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a periodic \u0e0b\u0e36\u0e48\u0e07\u0e16\u0e39\u0e01\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e42\u0e14\u0e22 MCU Polling \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e2d\u0e22\u0e44\u0e1b\u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e16\u0e32\u0e19\u0e30\u0e02\u0e2d\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e22\u0e46 Polling Diagram \u0e17\u0e33\u0e44\u0e21\u0e40\u0e1b\u0e47\u0e19\u0e1b\u0e31\u0e0d\u0e2b\u0e32 1. \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 Poll \u0e01\u0e47\u0e17\u0e33\u0e2d\u0e30\u0e44\u0e23\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 2. \u0e04\u0e27\u0e32\u0e21\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e19 Interrupt \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d interrupt \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 \u0e2b\u0e22\u0e38\u0e14 CPU \u0e44\u0e14\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e34\u0e14 event Interrupt Flowchart Simple Interrupt on the mbed \u0e1a\u0e2d\u0e23\u0e4c\u0e14 mbed \u0e43\u0e0a\u0e49 pin \u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 5 - 30 \u0e22\u0e01\u0e40\u0e27\u0e49\u0e19 19,20 \u0e40\u0e1b\u0e47\u0e19 Interrupt Function Usage InterruptIn(pin) \u0e2a\u0e23\u0e49\u0e32\u0e07 Object \u0e02\u0e2d\u0e07 Interrupt rise(ISR) \u0e43\u0e2b\u0e49 Interrupt trigger \u0e17\u0e35\u0e48\u0e02\u0e2d\u0e1a\u0e02\u0e32\u0e02\u0e35\u0e49\u0e19 \u0e1e\u0e23\u0e49\u0e2d\u0e21 Attach Interrupt Service Routine (ISR) (\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e21\u0e31\u0e19\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 event \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30) fall(ISR) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 rise \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32\u0e25\u0e07 mode \u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e17\u0e33\u0e44\u0e23\u0e44\u0e21\u0e48\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08 \u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14 #include \"mbed.h\" InterruptIn button(p5); //\u0e2a\u0e23\u0e49\u0e32\u0e07 object + \u0e01\u0e33\u0e2b\u0e19\u0e14 pin DigitalOut led(LED1); DigitalOut flash(LED4); void ISR1() { // \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e17\u0e35\u0e48\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 interrupt led = !led; } int main() { button.rise(&ISR1); // attach the address of the ISR //function to the interrupt rising edge while(1) { //continuous loop, ready to be interrupted flash = !flash; wait(0.25); } } Deeper into interrupt (\u0e02\u0e49\u0e2d\u0e14\u0e35 Interrupt) Prioritized \u0e1a\u0e32\u0e07 event \u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e46\u0e44\u0e14\u0e49 Masked \u0e40\u0e1b\u0e34\u0e14\u0e1b\u0e34\u0e14\u0e44\u0e14\u0e49 \u0e40\u0e1c\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32 Nested \u0e17\u0e33\u0e46\u0e2d\u0e22\u0e39\u0e48\u0e42\u0e14\u0e19\u0e41\u0e17\u0e23\u0e01\u0e08\u0e32\u0e01\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e1e\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e44\u0e14\u0e49 Location can be selected \u0e40\u0e25\u0e37\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e44\u0e27\u0e49\u0e43\u0e19 memory \u0e2a\u0e48\u0e27\u0e19\u0e44\u0e2b\u0e19 Delay between event occur and response is called latancy \u0e16\u0e49\u0e32 Interrupt \u0e23\u0e2d processor \u0e15\u0e2d\u0e1a \u0e40\u0e02\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Pending Interrupt Response in more detail Testing interrupt latency \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e19\u0e35\u0e49\u0e08\u0e30\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 Latency \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22\u0e42\u0e14\u0e22\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 \u0e01\u0e27\u0e48\u0e32 LED \u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 1 \u0e2b\u0e48\u0e32\u0e07\u0e08\u0e32\u0e01 input squarewave \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22 \u0e43\u0e19\u0e02\u0e13\u0e30\u0e17\u0e35\u0e48\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a LED \u0e43\u0e19 int main() #include \"mbed.h\" InterruptIn squarewave(p5); //Connect input square wave here DigitalOut led(p6); DigitalOut flash(LED4); void pulse() { //ISR sets external led high for fixed duration led = 1; wait(0.01); led = 0; } int main() { squarewave.rise(&pulse); // attach the address of the pulse function to // the rising edge while(1) { // interrupt will occur within this endless loop flash = !flash; wait(0.25); } } Interrupt from analog Inputs \u0e43\u0e0a\u0e49 Comparator \u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32 \\(V_-\\) \u0e40\u0e01\u0e34\u0e19 \\(V_+\\) Output \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 High \u0e04\u0e23\u0e31\u0e1a\u0e08\u0e1a\ud83d\ude1c Interrupt with analog The Digital Counter \u0e43\u0e0a\u0e49 Flip-Flop \u0e40\u0e1b\u0e47\u0e19 Counter \u0e42\u0e14\u0e22\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e01\u0e47\u0e02\u0e36\u0e49\u0e19\u0e01\u0e31\u0e1a\u0e08\u0e33\u0e19\u0e27\u0e19\u0e1a\u0e34\u0e15\u0e40\u0e0a\u0e48\u0e19 8 bit \u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 0-255 ( \\(0-(2^8-1)\\) ) \u0e41\u0e25\u0e30\u0e01\u0e47\u0e16\u0e49\u0e32\u0e15\u0e48\u0e2d\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Input \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 Clock \u0e21\u0e31\u0e19\u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a Clock \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e40\u0e1b\u0e47\u0e19 binary \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e14\u0e49, Preload \u0e44\u0e14\u0e49, \u0e08\u0e30 Reset \u0e40\u0e1b\u0e47\u0e19 0 \u0e01\u0e47\u0e44\u0e14\u0e49 Counting and Timing \u0e16\u0e49\u0e32 Clock Source \u0e02\u0e2d\u0e07 Counter \u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e04\u0e07\u0e17\u0e35\u0e48 Counter \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e08\u0e30\u0e01\u0e25\u0e32\u0e22\u0e40\u0e1b\u0e47\u0e19 Timer Ex. \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e16\u0e49\u0e32\u0e21\u0e35 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 1MHz (\u0e2d\u0e31\u0e19\u0e1a\u0e19) \u0e17\u0e38\u0e01 Clock Cycle \u0e17\u0e35\u0e48\u0e1c\u0e48\u0e32\u0e19\u0e44\u0e1b\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e48\u0e32\u0e43\u0e19 Counter \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e44\u0e1b 1 \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e04\u0e48\u0e32 Counter \u0e40\u0e19\u0e35\u0e49\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e19\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\u0e44\u0e14\u0e49 \u0e42\u0e14\u0e22 Counter \u0e41\u0e15\u0e48\u0e25\u0e30\u0e40\u0e25\u0e02\u0e01\u0e47\u0e08\u0e30\u0e21\u0e35\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32 1uS (1/1MHz) \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32 Counter \u0e21\u0e35\u0e04\u0e48\u0e32\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a 2000 \u0e01\u0e47\u0e41\u0e1b\u0e25\u0e27\u0e48\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e25\u0e49\u0e27 2000uS \u0e14\u0e39\u0e17\u0e23\u0e07\u0e25\u0e30\u0e23\u0e39\u0e1b\u0e44\u0e21\u0e48\u0e04\u0e48\u0e2d\u0e22\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48 \u0e41\u0e25\u0e30\u0e1e\u0e2d Counter \u0e21\u0e31\u0e19\u0e19\u0e31\u0e1a\u0e44\u0e1b\u0e08\u0e19\u0e2a\u0e38\u0e14\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e21\u0e31\u0e19 (aka Overflow) \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Interrupt \u0e02\u0e36\u0e49\u0e19\u0e41\u0e25\u0e49\u0e27\u0e01\u0e47\u0e08\u0e30 Reset \u0e04\u0e48\u0e32\u0e01\u0e25\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0 \u0e04\u0e38\u0e13\u0e2a\u0e21\u0e1a\u0e31\u0e15\u0e34\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e01\u0e33\u0e2b\u0e19\u0e14 event \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a synchronize \u0e01\u0e31\u0e19\u0e44\u0e14\u0e49 Timer Interrupt Event MBED Timer MBED \u0e21\u0e35 Timers Timer General Purpose 4 \u0e15\u0e31\u0e27 Repetitive Interrupt Timer System Tick Timer Timer \u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a Simple Timing application Timeout \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e2b\u0e21\u0e14\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e44\u0e27\u0e49 (\u0e41\u0e1a\u0e1a non-blocking) Ticker \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e17\u0e35\u0e48\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 Timer \u0e17\u0e33\u0e44\u0e14\u0e49\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49 Function Usage start Start Timer stop Stop Timer reset Reset timer to 0 read get passed time in seconds read_ms get passed time in milliseconds read_us get passed time in microseconds Simple timer application \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e01\u0e47 Start Timer -> \u0e1b\u0e23\u0e34\u0e49\u0e19 Hello World \u0e41\u0e25\u0e30 Stop Timer \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25(\u0e21\u0e31\u0e49\u0e07) #include \"mbed.h\" Timer t; // define Timer with name \u201ct\u201d Serial pc(USBTX, USBRX); int main() { t.start(); //start the timer pc.printf(\"Hello World!\\n\"); t.stop(); //stop the timer //print to pc pc.printf(\"The time taken was %f seconds\\n\", t.read()); } mbed Timeout \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | detach(ISR) |Detach the function| #include \"mbed.h\" Timeout Response; //create a Timeout, and name it \"Response\" DigitalIn button (p5); DigitalOut led1(LED1); //blinks in time with main while(1) loop DigitalOut led2(LED2); //set high fixed period after button press DigitalOut led3(LED3); //goes high when button is pressed void blink() { //this function is called at the end of the Timeout led2 = 1; wait(0.5); led2=0; } int main() { while(1) { if(button==1){ Response.attach(&blink,2.0); //attach blink function to Response //Timeout, to occur after 2 seconds led3=1; //shows button has been pressed } else { led3=0; } led1=!led1; wait(0.2); } } mbed Ticker \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | detach(ISR) |Detach the function| #include \"mbed.h\" void led_switch(void); // Prototype function Ticker time_up; //define a Ticker, with name \u201ctime_up\u201d DigitalOut myled(LED1); void led_switch(){ //the function that Ticker will call myled=!myled; } int main(){ time_up.attach(&led_switch, 0.2); //initialises the ticker while(1){ //sit in a loop doing nothing, waiting for //Ticker interrupt } } Real Time Clock RTC (Real time clock) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d\u0e19\u0e32\u0e2c\u0e34\u0e01\u0e32\u0e17\u0e35\u0e48\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e21\u0e32\u0e01 \u0e43\u0e0a\u0e49 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 32kHz Function Usage Time Get Current Time set_time Set Current Time mktime converts converts the time structure into a calender time value localtime Converts a timestamp to a tm structure ctime Converts a timestamp to a human-readable string strftime Converts a tm structure to a custom format human-readable string #include \"mbed.h\" InterruptIn button(p18); // Interrupt on digital pushbutton input p18 DigitalOut led1(LED1); // digital out to LED1 Timer debounce; // define debounce timer void toggle(void); // function prototype int main() { debounce.start(); button.rise(&toggle); // attach the address of the toggle } // function to the rising edge void toggle() { if (debounce.read_ms()>10) // only allow toggle if debounce timer led1=!led1; // has passed 10 ms debounce.reset(); // restart timer when the toggle is performed } Realtime Operating System (RTOS) \u0e21\u0e35 OS \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e2a\u0e23\u0e23\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23 \u0e41\u0e1a\u0e48\u0e07\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23\u0e01\u0e31\u0e19 \u0e23\u0e31\u0e19\u0e42\u0e04\u0e49\u0e14\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Task \u0e2b\u0e23\u0e37\u0e2d Threads \u0e42\u0e14\u0e22 RTOS \u0e17\u0e33 2 \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e2b\u0e25\u0e31\u0e01\u0e46 Decides which Program run for how long Provide Commu and Sync between tasks Control overall resource RTOS Scheduling RTOS \u0e22\u0e31\u0e07\u0e21\u0e35 Scheduler \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e27\u0e48\u0e32 Task \u0e44\u0e2b\u0e19\u0e23\u0e31\u0e19 \u0e41\u0e25\u0e30\u0e23\u0e31\u0e19\u0e19\u0e32\u0e19\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Ex. Round Robin Scheduler sync activity to clock tick \u0e41\u0e15\u0e48 Round robin \u0e08\u0e30 Switch \u0e17\u0e38\u0e01 Clock Tick \u0e44\u0e21\u0e48\u0e27\u0e48\u0e32 Task \u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e07 \u0e01\u0e47\u0e40\u0e25\u0e22\u0e44\u0e21\u0e48\u0e21\u0e35 Task Prioritization (\u0e41\u0e15\u0e48 scheduler \u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e21\u0e35\u0e19\u0e30)","title":"Chapter 9"},{"location":"interrupt/#chapter-9-interrupts-timers-and-tasks","text":"\u0e1b\u0e4d\u0e0d\u0e2b\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e1b\u0e31\u0e0d\u0e2b\u0e32 \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e17\u0e31\u0e28\u0e19\u0e04\u0e15\u0e34\u0e02\u0e2d\u0e07 \u0e21\u0e36\u0e07 \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e1b\u0e31\u0e0d\u0e2b\u0e32 - \u0e23\u0e38\u0e01\u0e01\u0e35\u0e49","title":"Chapter 9 Interrupts Timers and Tasks"},{"location":"interrupt/#timer-and-interrupts","text":"","title":"Timer and Interrupts"},{"location":"interrupt/#mcu","text":"\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32 \u0e2a\u0e23\u0e49\u0e32\u0e07 time-based event (\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e14\u0e35\u0e22\u0e27 \u0e2b\u0e23\u0e37\u0e2d\u0e2b\u0e25\u0e32\u0e22\u0e04\u0e23\u0e31\u0e49\u0e07) \u0e15\u0e2d\u0e1a\u0e2a\u0e19\u0e2d\u0e07 \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e23\u0e27\u0e14\u0e40\u0e23\u0e47\u0e27","title":"MCU \u0e15\u0e49\u0e2d\u0e07\u0e17\u0e33\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e44\u0e14\u0e49"},{"location":"interrupt/#tasks-event-triggered-and-time-triggered","text":"","title":"Tasks : Event-Triggered and Time-Triggered"},{"location":"interrupt/#event-triggered","text":"\u0e40\u0e01\u0e34\u0e14\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 event \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e21\u0e32\u0e01\u0e23\u0e30\u0e15\u0e38\u0e49\u0e19","title":"Event-Triggered"},{"location":"interrupt/#time-triggered","text":"\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a periodic \u0e0b\u0e36\u0e48\u0e07\u0e16\u0e39\u0e01\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e42\u0e14\u0e22 MCU","title":"Time-Triggered"},{"location":"interrupt/#polling","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e2d\u0e22\u0e44\u0e1b\u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e16\u0e32\u0e19\u0e30\u0e02\u0e2d\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e22\u0e46 Polling Diagram","title":"Polling"},{"location":"interrupt/#_1","text":"","title":"\u0e17\u0e33\u0e44\u0e21\u0e40\u0e1b\u0e47\u0e19\u0e1b\u0e31\u0e0d\u0e2b\u0e32"},{"location":"interrupt/#1-poll","text":"","title":"1. \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 Poll \u0e01\u0e47\u0e17\u0e33\u0e2d\u0e30\u0e44\u0e23\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49"},{"location":"interrupt/#2","text":"","title":"2. \u0e04\u0e27\u0e32\u0e21\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e02\u0e2d\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e19"},{"location":"interrupt/#interrupt","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d interrupt \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 \u0e2b\u0e22\u0e38\u0e14 CPU \u0e44\u0e14\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e34\u0e14 event Interrupt Flowchart","title":"Interrupt"},{"location":"interrupt/#simple-interrupt-on-the-mbed","text":"\u0e1a\u0e2d\u0e23\u0e4c\u0e14 mbed \u0e43\u0e0a\u0e49 pin \u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 5 - 30 \u0e22\u0e01\u0e40\u0e27\u0e49\u0e19 19,20 \u0e40\u0e1b\u0e47\u0e19 Interrupt Function Usage InterruptIn(pin) \u0e2a\u0e23\u0e49\u0e32\u0e07 Object \u0e02\u0e2d\u0e07 Interrupt rise(ISR) \u0e43\u0e2b\u0e49 Interrupt trigger \u0e17\u0e35\u0e48\u0e02\u0e2d\u0e1a\u0e02\u0e32\u0e02\u0e35\u0e49\u0e19 \u0e1e\u0e23\u0e49\u0e2d\u0e21 Attach Interrupt Service Routine (ISR) (\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e21\u0e31\u0e19\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 event \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30) fall(ISR) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 rise \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32\u0e25\u0e07 mode \u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e17\u0e33\u0e44\u0e23\u0e44\u0e21\u0e48\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08","title":"Simple Interrupt on the mbed"},{"location":"interrupt/#_2","text":"#include \"mbed.h\" InterruptIn button(p5); //\u0e2a\u0e23\u0e49\u0e32\u0e07 object + \u0e01\u0e33\u0e2b\u0e19\u0e14 pin DigitalOut led(LED1); DigitalOut flash(LED4); void ISR1() { // \u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e17\u0e35\u0e48\u0e17\u0e33\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 interrupt led = !led; } int main() { button.rise(&ISR1); // attach the address of the ISR //function to the interrupt rising edge while(1) { //continuous loop, ready to be interrupted flash = !flash; wait(0.25); } }","title":"\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e42\u0e04\u0e49\u0e14"},{"location":"interrupt/#deeper-into-interrupt-interrupt","text":"Prioritized \u0e1a\u0e32\u0e07 event \u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e46\u0e44\u0e14\u0e49 Masked \u0e40\u0e1b\u0e34\u0e14\u0e1b\u0e34\u0e14\u0e44\u0e14\u0e49 \u0e40\u0e1c\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32 Nested \u0e17\u0e33\u0e46\u0e2d\u0e22\u0e39\u0e48\u0e42\u0e14\u0e19\u0e41\u0e17\u0e23\u0e01\u0e08\u0e32\u0e01\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e2a\u0e1e\u0e04\u0e31\u0e0d\u0e01\u0e27\u0e48\u0e32\u0e44\u0e14\u0e49 Location can be selected \u0e40\u0e25\u0e37\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e44\u0e27\u0e49\u0e43\u0e19 memory \u0e2a\u0e48\u0e27\u0e19\u0e44\u0e2b\u0e19 Delay between event occur and response is called latancy \u0e16\u0e49\u0e32 Interrupt \u0e23\u0e2d processor \u0e15\u0e2d\u0e1a \u0e40\u0e02\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Pending Interrupt Response in more detail","title":"Deeper into interrupt (\u0e02\u0e49\u0e2d\u0e14\u0e35 Interrupt)"},{"location":"interrupt/#testing-interrupt-latency","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e19\u0e35\u0e49\u0e08\u0e30\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 Latency \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22\u0e42\u0e14\u0e22\u0e27\u0e31\u0e14\u0e27\u0e48\u0e32 \u0e01\u0e27\u0e48\u0e32 LED \u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 1 \u0e2b\u0e48\u0e32\u0e07\u0e08\u0e32\u0e01 input squarewave \u0e40\u0e22\u0e2d\u0e30\u0e21\u0e31\u0e49\u0e22 \u0e43\u0e19\u0e02\u0e13\u0e30\u0e17\u0e35\u0e48\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a LED \u0e43\u0e19 int main() #include \"mbed.h\" InterruptIn squarewave(p5); //Connect input square wave here DigitalOut led(p6); DigitalOut flash(LED4); void pulse() { //ISR sets external led high for fixed duration led = 1; wait(0.01); led = 0; } int main() { squarewave.rise(&pulse); // attach the address of the pulse function to // the rising edge while(1) { // interrupt will occur within this endless loop flash = !flash; wait(0.25); } }","title":"Testing interrupt latency"},{"location":"interrupt/#interrupt-from-analog-inputs","text":"\u0e43\u0e0a\u0e49 Comparator \u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e02\u0e32 \\(V_-\\) \u0e40\u0e01\u0e34\u0e19 \\(V_+\\) Output \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 High \u0e04\u0e23\u0e31\u0e1a\u0e08\u0e1a\ud83d\ude1c Interrupt with analog","title":"Interrupt from analog Inputs"},{"location":"interrupt/#the-digital-counter","text":"\u0e43\u0e0a\u0e49 Flip-Flop \u0e40\u0e1b\u0e47\u0e19 Counter \u0e42\u0e14\u0e22\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e01\u0e47\u0e02\u0e36\u0e49\u0e19\u0e01\u0e31\u0e1a\u0e08\u0e33\u0e19\u0e27\u0e19\u0e1a\u0e34\u0e15\u0e40\u0e0a\u0e48\u0e19 8 bit \u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a\u0e44\u0e14\u0e49\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 0-255 ( \\(0-(2^8-1)\\) ) \u0e41\u0e25\u0e30\u0e01\u0e47\u0e16\u0e49\u0e32\u0e15\u0e48\u0e2d\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Input \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 Clock \u0e21\u0e31\u0e19\u0e01\u0e47\u0e08\u0e30\u0e19\u0e31\u0e1a Clock \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e40\u0e1b\u0e47\u0e19 binary \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e14\u0e49, Preload \u0e44\u0e14\u0e49, \u0e08\u0e30 Reset \u0e40\u0e1b\u0e47\u0e19 0 \u0e01\u0e47\u0e44\u0e14\u0e49","title":"The Digital Counter"},{"location":"interrupt/#counting-and-timing","text":"\u0e16\u0e49\u0e32 Clock Source \u0e02\u0e2d\u0e07 Counter \u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e04\u0e07\u0e17\u0e35\u0e48 Counter \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e08\u0e30\u0e01\u0e25\u0e32\u0e22\u0e40\u0e1b\u0e47\u0e19 Timer Ex. \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e16\u0e49\u0e32\u0e21\u0e35 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 1MHz (\u0e2d\u0e31\u0e19\u0e1a\u0e19) \u0e17\u0e38\u0e01 Clock Cycle \u0e17\u0e35\u0e48\u0e1c\u0e48\u0e32\u0e19\u0e44\u0e1b\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e48\u0e32\u0e43\u0e19 Counter \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e44\u0e1b 1 \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e04\u0e48\u0e32 Counter \u0e40\u0e19\u0e35\u0e49\u0e22\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e19\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\u0e44\u0e14\u0e49 \u0e42\u0e14\u0e22 Counter \u0e41\u0e15\u0e48\u0e25\u0e30\u0e40\u0e25\u0e02\u0e01\u0e47\u0e08\u0e30\u0e21\u0e35\u0e23\u0e30\u0e22\u0e30\u0e40\u0e27\u0e25\u0e32 1uS (1/1MHz) \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32 Counter \u0e21\u0e35\u0e04\u0e48\u0e32\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a 2000 \u0e01\u0e47\u0e41\u0e1b\u0e25\u0e27\u0e48\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e25\u0e49\u0e27 2000uS \u0e14\u0e39\u0e17\u0e23\u0e07\u0e25\u0e30\u0e23\u0e39\u0e1b\u0e44\u0e21\u0e48\u0e04\u0e48\u0e2d\u0e22\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48 \u0e41\u0e25\u0e30\u0e1e\u0e2d Counter \u0e21\u0e31\u0e19\u0e19\u0e31\u0e1a\u0e44\u0e1b\u0e08\u0e19\u0e2a\u0e38\u0e14\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e21\u0e31\u0e19 (aka Overflow) \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Interrupt \u0e02\u0e36\u0e49\u0e19\u0e41\u0e25\u0e49\u0e27\u0e01\u0e47\u0e08\u0e30 Reset \u0e04\u0e48\u0e32\u0e01\u0e25\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 0 \u0e04\u0e38\u0e13\u0e2a\u0e21\u0e1a\u0e31\u0e15\u0e34\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e01\u0e33\u0e2b\u0e19\u0e14 event \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e01\u0e34\u0e14\u0e41\u0e1a\u0e1a synchronize \u0e01\u0e31\u0e19\u0e44\u0e14\u0e49 Timer Interrupt Event","title":"Counting and Timing"},{"location":"interrupt/#mbed-timer","text":"","title":"MBED Timer"},{"location":"interrupt/#mbed-timers","text":"Timer General Purpose 4 \u0e15\u0e31\u0e27 Repetitive Interrupt Timer System Tick Timer Timer \u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a Simple Timing application Timeout \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e2b\u0e21\u0e14\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e44\u0e27\u0e49 (\u0e41\u0e1a\u0e1a non-blocking) Ticker \u0e43\u0e0a\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e48\u0e19\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e17\u0e35\u0e48\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14","title":"MBED \u0e21\u0e35 Timers"},{"location":"interrupt/#timer","text":"Function Usage start Start Timer stop Stop Timer reset Reset timer to 0 read get passed time in seconds read_ms get passed time in milliseconds read_us get passed time in microseconds","title":"Timer \u0e17\u0e33\u0e44\u0e14\u0e49\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49"},{"location":"interrupt/#simple-timer-application","text":"\u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e01\u0e47 Start Timer -> \u0e1b\u0e23\u0e34\u0e49\u0e19 Hello World \u0e41\u0e25\u0e30 Stop Timer \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e27\u0e31\u0e14\u0e40\u0e27\u0e25\u0e32\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25(\u0e21\u0e31\u0e49\u0e07) #include \"mbed.h\" Timer t; // define Timer with name \u201ct\u201d Serial pc(USBTX, USBRX); int main() { t.start(); //start the timer pc.printf(\"Hello World!\\n\"); t.stop(); //stop the timer //print to pc pc.printf(\"The time taken was %f seconds\\n\", t.read()); }","title":"Simple timer application"},{"location":"interrupt/#mbed-timeout","text":"\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e40\u0e23\u0e35\u0e22\u0e01\u0e15\u0e2d\u0e19\u0e40\u0e01\u0e34\u0e14 timeout| | detach(ISR) |Detach the function| #include \"mbed.h\" Timeout Response; //create a Timeout, and name it \"Response\" DigitalIn button (p5); DigitalOut led1(LED1); //blinks in time with main while(1) loop DigitalOut led2(LED2); //set high fixed period after button press DigitalOut led3(LED3); //goes high when button is pressed void blink() { //this function is called at the end of the Timeout led2 = 1; wait(0.5); led2=0; } int main() { while(1) { if(button==1){ Response.attach(&blink,2.0); //attach blink function to Response //Timeout, to occur after 2 seconds led3=1; //shows button has been pressed } else { led3=0; } led1=!led1; wait(0.2); } }","title":"mbed Timeout"},{"location":"interrupt/#mbed-ticker","text":"\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e01\u0e43\u0e0a\u0e49\u0e15\u0e32\u0e21\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e01\u0e33\u0e2b\u0e19\u0e14 |Function|Usage| |---|---| | attach(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35 \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | attach_us(ISR,seconds) |Attach member?? function \u0e41\u0e25\u0e30\u0e08\u0e33\u0e19\u0e27\u0e19 microseconds \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e2b\u0e49 ticker \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e16\u0e36\u0e07\u0e40\u0e27\u0e25\u0e32| | detach(ISR) |Detach the function| #include \"mbed.h\" void led_switch(void); // Prototype function Ticker time_up; //define a Ticker, with name \u201ctime_up\u201d DigitalOut myled(LED1); void led_switch(){ //the function that Ticker will call myled=!myled; } int main(){ time_up.attach(&led_switch, 0.2); //initialises the ticker while(1){ //sit in a loop doing nothing, waiting for //Ticker interrupt } }","title":"mbed Ticker"},{"location":"interrupt/#real-time-clock","text":"RTC (Real time clock) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d\u0e19\u0e32\u0e2c\u0e34\u0e01\u0e32\u0e17\u0e35\u0e48\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e21\u0e32\u0e01 \u0e43\u0e0a\u0e49 Clock \u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48 32kHz Function Usage Time Get Current Time set_time Set Current Time mktime converts converts the time structure into a calender time value localtime Converts a timestamp to a tm structure ctime Converts a timestamp to a human-readable string strftime Converts a tm structure to a custom format human-readable string #include \"mbed.h\" InterruptIn button(p18); // Interrupt on digital pushbutton input p18 DigitalOut led1(LED1); // digital out to LED1 Timer debounce; // define debounce timer void toggle(void); // function prototype int main() { debounce.start(); button.rise(&toggle); // attach the address of the toggle } // function to the rising edge void toggle() { if (debounce.read_ms()>10) // only allow toggle if debounce timer led1=!led1; // has passed 10 ms debounce.reset(); // restart timer when the toggle is performed }","title":"Real Time Clock"},{"location":"interrupt/#realtime-operating-system-rtos","text":"\u0e21\u0e35 OS \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e08\u0e31\u0e14\u0e2a\u0e23\u0e23\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23 \u0e41\u0e1a\u0e48\u0e07\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e32\u0e01\u0e23\u0e01\u0e31\u0e19 \u0e23\u0e31\u0e19\u0e42\u0e04\u0e49\u0e14\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Task \u0e2b\u0e23\u0e37\u0e2d Threads \u0e42\u0e14\u0e22 RTOS \u0e17\u0e33 2 \u0e2d\u0e22\u0e48\u0e32\u0e07\u0e2b\u0e25\u0e31\u0e01\u0e46 Decides which Program run for how long Provide Commu and Sync between tasks Control overall resource","title":"Realtime Operating System (RTOS)"},{"location":"interrupt/#rtos-scheduling","text":"RTOS \u0e22\u0e31\u0e07\u0e21\u0e35 Scheduler \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e27\u0e48\u0e32 Task \u0e44\u0e2b\u0e19\u0e23\u0e31\u0e19 \u0e41\u0e25\u0e30\u0e23\u0e31\u0e19\u0e19\u0e32\u0e19\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Ex. Round Robin Scheduler sync activity to clock tick \u0e41\u0e15\u0e48 Round robin \u0e08\u0e30 Switch \u0e17\u0e38\u0e01 Clock Tick \u0e44\u0e21\u0e48\u0e27\u0e48\u0e32 Task \u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e07 \u0e01\u0e47\u0e40\u0e25\u0e22\u0e44\u0e21\u0e48\u0e21\u0e35 Task Prioritization (\u0e41\u0e15\u0e48 scheduler \u0e2d\u0e31\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e21\u0e35\u0e19\u0e30)","title":"RTOS Scheduling"},{"location":"memory/","text":"Chapter 10 Memory and Data Management Memory Memory Function Types Memory \u0e43\u0e19 microcontroller \u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e2b\u0e19\u0e49\u0e32\u0e17\u0e35\u0e48\u0e2b\u0e25\u0e31\u0e01\u0e46\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e01\u0e47\u0e04\u0e37\u0e2d Program Memory \u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e41\u0e25\u0e30 Data Memory \u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e2d\u0e19\u0e17\u0e33\u0e07\u0e32\u0e19 Electronic Memory \u0e08\u0e30\u0e21\u0e38\u0e48\u0e07\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e41\u0e04\u0e48 0 \u0e01\u0e31\u0e1a 1 (\u0e0b\u0e36\u0e48\u0e07\u0e21\u0e21\u0e31\u0e19\u0e01\u0e47 Stable \u0e41\u0e04\u0e48 2 state \u0e40\u0e23\u0e32\u0e40\u0e25\u0e22\u0e40\u0e23\u0e35\u0e22\u0e01\u0e21\u0e31\u0e19\u0e27\u0e48\u0e32 Bistable ) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e40\u0e2b\u0e23\u0e35\u0e22\u0e0d\u0e21\u0e35\u0e2b\u0e31\u0e27\u0e01\u0e31\u0e1a\u0e01\u0e49\u0e2d\u0e22\u0e2d\u0e48\u0e30 \u0e01\u0e35\u0e48 bit \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e21\u0e35\u0e01\u0e35\u0e48\u0e40\u0e2b\u0e23\u0e35\u0e22\u0e0d \u0e41\u0e15\u0e48\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e19\u0e40\u0e2b\u0e23\u0e35\u0e0d\u0e40\u0e19\u0e2d\u0e30 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32\u0e40\u0e01\u0e47\u0e1a\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a Electronic \u0e01\u0e47\u0e43\u0e0a\u0e49 Flip-Flop \u0e41\u0e17\u0e19 1 bit Flip Flop \u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48\u0e23\u0e2d\u0e07\u0e40\u0e17\u0e49\u0e32 Electronic Memory Types \u0e41\u0e1a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 2 \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Volatile Memory \u0e40\u0e1b\u0e47\u0e19 Memory \u0e41\u0e1a\u0e1a\u0e17\u0e35\u0e48\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e2b\u0e32\u0e22\u0e40\u0e27\u0e25\u0e32\u0e44\u0e1f\u0e15\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e16\u0e39\u0e01\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Data Memory \u0e2b\u0e23\u0e37\u0e2d RAM \u0e41\u0e1a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e2d\u0e35\u0e01 DRAM SRAM Non-Volatile Memory \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e21\u0e48\u0e2b\u0e32\u0e22\u0e40\u0e27\u0e25\u0e32\u0e44\u0e1f\u0e15\u0e31\u0e14 \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e2b\u0e23\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19 Program Memory \u0e0b\u0e36\u0e48\u0e07\u0e2a\u0e21\u0e38\u0e22\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e23\u0e32\u0e23\u0e39\u0e49\u0e08\u0e31\u0e01\u0e01\u0e31\u0e19\u0e43\u0e19\u0e0a\u0e37\u0e48\u0e2d ROM (Read only memory) \u0e41\u0e1a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e2d\u0e35\u0e01 ROM PROM EPROM EEPROM FLASH Pointer Introduction \u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e43\u0e19\u0e20\u0e32\u0e29\u0e32 C Pointer \u0e43\u0e0a\u0e49\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e04\u0e23\u0e31\u0e1a (\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e17\u0e35\u0e48\u0e27\u0e48\u0e32\u0e19\u0e35\u0e48\u0e04\u0e37\u0e2d\u0e17\u0e31\u0e49\u0e07\u0e23\u0e39\u0e49 Address \u0e41\u0e25\u0e30\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22\u0e19\u0e30) \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 Array \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 Pointer \u0e16\u0e49\u0e32\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 int data[10] = {1,2,3,4,5,6,7,8,9,10}; int main(void){ printf(\"%d\",data); return 0; } \u0e16\u0e49\u0e32 printf(\"%d\",data); \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e04\u0e48\u0e32\u0e17\u0e31\u0e49\u0e07 Array \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e43\u0e19 JS \u0e2b\u0e23\u0e37\u0e2d Python \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e41\u0e15\u0e48\u0e08\u0e30\u0e44\u0e14\u0e49 Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e41\u0e23\u0e01\u0e2d\u0e2d\u0e01\u0e21\u0e32 Defining Pointer \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01 Array \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e35\u0e49\u0e41\u0e25\u0e49\u0e27\u0e22\u0e31\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 Define Pointer \u0e44\u0e14\u0e49\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 \u0e42\u0e14\u0e22\u0e43\u0e2a\u0e48 * \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e0a\u0e37\u0e48\u0e2d\u0e41\u0e1b\u0e23 int *ptr; // define a pointer which points to data of type int \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Pointer \u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e23\u0e31\u0e1a\u0e40\u0e01\u0e47\u0e1a Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e01\u0e47\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 Assign Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e19\u0e31\u0e49\u0e19\u0e44\u0e14\u0e49\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 \u0e2a\u0e31\u0e07\u0e40\u0e01\u0e15\u0e27\u0e48\u0e32\u0e40\u0e2d\u0e32 address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e44\u0e14\u0e49\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e43\u0e2a\u0e48 & \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 int datavariable=7; // define a variable called datavariable with value 7 int *ptr; // define a pointer which points to data of type int ptr = &datavariable;// assign the pointer to the address of datavariable \u0e2b\u0e23\u0e37\u0e2d\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 Array \u0e41\u0e1a\u0e1a\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e35\u0e49 (\u0e01\u0e23\u0e13\u0e35\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49 Address \u0e02\u0e2d\u0e07 Element Array index \u0e17\u0e35\u0e48 0) int array[]={3,4,6,2,8,9,1,4,6}; // define an array of arbitrary values int *ptr // define a pointer ptr = &array[0]; // assign pointer to the address of the first element of the array Pointers with array and functions /* Program Example 10.5: Pointers example for an array average function */ #include \"mbed.h\" Serial pc(USBTX, USBRX); // setup serial comms char data[]={5,7,5,8,9,1,7,8,2,5,1,4,6,2,1}; // define some input data char *dataptr; // define a pointer for the input data float average; // floating point average variable float CalculateAverage(char *ptr, char size); // function prototype int main() { dataptr=&data[0]; // point to address of the first array element average = CalculateAverage(dataptr, sizeof(data)); // call function pc.printf(\"\\n\\rdata = \"); for (char i=0; i<sizeof(data); i++) { // loop for each data value pc.printf(\"%d \",data[i]); // display all the data values } pc.printf(\"\\n\\raverage = %.3f\",average); // display average value } // CalculateAverage function definition and code float CalculateAverage(char *ptr, char size) { int sum=0; // variable for calculating the sum of the data float mean; // variable for floating point mean value for (char i=0; i<size; i++) { sum=sum + *(ptr+i); // add all data elements together } mean=(float)sum/size; // divide by size and cast to floating point return mean; } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e44\u0e2d\u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2a\u0e23\u0e49\u0e32\u0e07 function CalculateAverage \u0e42\u0e14\u0e22\u0e23\u0e31\u0e1a Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e41\u0e23\u0e01\u0e02\u0e2d\u0e07 array \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e1a size \u0e02\u0e2d\u0e07 Array \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e04\u0e33\u0e19\u0e27\u0e19 (\u0e43\u0e0a\u0e48\u0e04\u0e23\u0e31\u0e1a \u0e43\u0e2a\u0e48 Array \u0e40\u0e02\u0e49\u0e32\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e2a\u0e48\u0e02\u0e19\u0e32\u0e14\u0e14\u0e49\u0e27\u0e22) \u0e41\u0e25\u0e30\u0e43\u0e19\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e44\u0e14\u0e49\u0e40\u0e2b\u0e47\u0e19\u0e01\u0e32\u0e23\u0e40\u0e2d\u0e32\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e08\u0e32\u0e01 Address \u0e19\u0e31\u0e49\u0e19 \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e32\u0e23 Dereferencing \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e2a\u0e48 * \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 pointer Files FILE *fopen(const char *filename, const char*mode); // \u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1b\u0e25\u0e4c int fclose(FILE *stream); // \u0e1b\u0e34\u0e14\u0e44\u0e1b\u0e25\u0e4c int fgetc(FILE *stream); // \u0e2d\u0e48\u0e32\u0e19 Character 1 \u0e15\u0e31\u0e27\u0e08\u0e32\u0e01\u0e44\u0e1f\u0e25\u0e4c char *fgets(char *str, int n, FILE *stream); // \u0e2d\u0e48\u0e32\u0e19 String \u0e08\u0e32\u0e01\u0e44\u0e1f\u0e25\u0e4c int fputc(int character, FILE *stream); // \u0e40\u0e02\u0e35\u0e22\u0e19 Character 1 \u0e15\u0e31\u0e27\u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fputs(const char *str, FILE *stream); // \u0e40\u0e02\u0e35\u0e22\u0e19 String \u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fprintf(FILE *stream, const char *format,...); // \u0e40\u0e02\u0e35\u0e22\u0e19 Formatted String \u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fseek(FILE *stream, long int offset, int origin); // \u0e40\u0e25\u0e37\u0e48\u0e2d\u0e19\u0e15\u0e33\u0e41\u0e2b\u0e19\u0e48\u0e07\u0e17\u0e35\u0e48\u0e08\u0e30\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e1f\u0e25\u0e4c Using data files on the mbed \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 File \u0e43\u0e19 MBED \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 LocalFileSystem \u0e44\u0e14\u0e49 \u0e43\u0e0a\u0e49\u0e07\u0e35\u0e49 LocalFileSystem local(\"local\"); //Create file system named \"local\" \u0e17\u0e35\u0e19\u0e35\u0e49\u0e01\u0e47\u0e43\u0e0a\u0e49\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e02\u0e2d\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e02\u0e49\u0e32\u0e07\u0e1a\u0e19\u0e44\u0e14\u0e49\u0e15\u0e32\u0e21\u0e1b\u0e01\u0e15\u0e34 FILE* pFile = fopen(\"/local/datafile.txt\",\"w\"); // note the \u201cw\u201d refers to a file with write access \u0e1e\u0e2d\u0e43\u0e0a\u0e49\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e01\u0e47\u0e1b\u0e34\u0e14 fclose(pFile); \u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07 /* Program Example 10.1: read and write char data bytes */ #include \"mbed.h\" Serial pc(USBTX,USBRX); // setup terminal link LocalFileSystem local(\"local\"); // define local file system int write_var; int read_var; // create data variables int main () { FILE* File1 = fopen(\"/local/datafile.txt\",\"w\"); // open file write_var=0x23; // example data fputc(write_var, File1); // put char (data value) into file fclose(File1); // close file FILE* File2 = fopen (\"/local/datafile.txt\",\"r\"); // open file for reading read_var = fgetc(File2); // read first data value fclose(File2); // close file pc.printf(\"input value = %i \\n\",read_var); // display read data value } \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1f\u0e25\u0e4c\u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e02\u0e35\u0e22\u0e19 character 1 \u0e15\u0e31\u0e27\u0e25\u0e07\u0e44\u0e1b /* Program Example 10.2: Read and write text string data */ #include \"mbed.h\" Serial pc(USBTX,USBRX); // setup terminal link LocalFileSystem local(\"local\"); // define local file system char write_string[64]; // character array up to 64 characters char read_string[64]; // create character arrays (strings) int main () { FILE* File1 = fopen(\"/local/textfile.txt\",\"w\"); // open file access fputs(\"lots and lots of words and letters\", File1);// put text into file fclose(File1); // close file FILE* File2 = fopen (\"/local/textfile.txt\",\"r\"); // open file for reading fgets(read_string,256,File2); // read text into variable fclose(File2); // close file pc.printf(\"text data: %s \\n\",read_string); // display read data string } \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1f\u0e25\u0e4c\u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e02\u0e35\u0e22\u0e19 string \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e25\u0e07\u0e44\u0e1b Using external memory with the mbed MBED \u0e15\u0e48\u0e2d Storage \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e19\u0e30 \u0e15\u0e48\u0e2d\u0e44\u0e14\u0e49 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d SD Card \u0e2b\u0e23\u0e37\u0e2d USB Flashdrive \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 SD Card \u0e15\u0e48\u0e2d\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 SD Card connection table /* Program Example 10.4: writing data to an SD card */ #include \"mbed.h\" #include \"SDFileSystem.h\" SDFileSystem sd(p5, p6, p7, p8, \"sd\"); // MOSI, MISO, SCLK, CS Serial pc(USBTX, USBRX); int main() { FILE *File = fopen(\"/sd/sdfile.txt\", \"w\"); // open file if(File == NULL) { // check for file pointer pc.printf(\"Could not open file for write\\n\"); // error if no pointer } else{ pc.printf(\"SD card file successfully opened\\n\"); // if pointer ok } fprintf(File, \"Here's some sample text on the SD card\"); // write data fclose(File); // close file } \u0e44\u0e21\u0e48\u0e01\u0e47\u0e43\u0e0a\u0e49 External USB Flash Drive MBED \u0e1a\u0e2d\u0e14\u0e19\u0e35\u0e49\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 USB Host \u0e44\u0e14\u0e49 (\u0e40\u0e1e\u0e23\u0e32\u0e30 USB Builtin \u0e17\u0e35\u0e48\u0e02\u0e32 31,32) \u0e42\u0e14\u0e22 Library USBHostMSD /* Program Example 10.5: writing data to an USB flash storage device */ #include \"mbed.h\" #include \"USBHostMSD.h\" int main() { USBHostMSD usb(\"usb\"); // define USBHostMSD object while(!usb.connect()) { // try to connect a USB storage before continuing wait(0.5); printf(\"Connecting to USB MSD\\n\"); } FILE *File = fopen(\"/usb/usbfile.txt\", \"w\"); // open file if(File == NULL) { // check for file pointer intf(\"Could not open file for write\\n\"); // error if no pointer } else{ p tf(\"USB card file successfully opened\\n\"); // if pointer ok } fprintf(File, \"Here's some sample text on the USB card\"); // write data fclose(File); // close file }","title":"Chapter 10"},{"location":"memory/#chapter-10-memory-and-data-management","text":"","title":"Chapter 10 Memory and Data Management"},{"location":"memory/#memory","text":"","title":"Memory"},{"location":"memory/#memory-function-types","text":"Memory \u0e43\u0e19 microcontroller \u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e2b\u0e19\u0e49\u0e32\u0e17\u0e35\u0e48\u0e2b\u0e25\u0e31\u0e01\u0e46\u0e01\u0e47\u0e04\u0e37\u0e2d\u0e43\u0e0a\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e01\u0e47\u0e04\u0e37\u0e2d Program Memory \u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 \u0e41\u0e25\u0e30 Data Memory \u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e2d\u0e19\u0e17\u0e33\u0e07\u0e32\u0e19 Electronic Memory \u0e08\u0e30\u0e21\u0e38\u0e48\u0e07\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e41\u0e04\u0e48 0 \u0e01\u0e31\u0e1a 1 (\u0e0b\u0e36\u0e48\u0e07\u0e21\u0e21\u0e31\u0e19\u0e01\u0e47 Stable \u0e41\u0e04\u0e48 2 state \u0e40\u0e23\u0e32\u0e40\u0e25\u0e22\u0e40\u0e23\u0e35\u0e22\u0e01\u0e21\u0e31\u0e19\u0e27\u0e48\u0e32 Bistable ) \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e40\u0e2b\u0e23\u0e35\u0e22\u0e0d\u0e21\u0e35\u0e2b\u0e31\u0e27\u0e01\u0e31\u0e1a\u0e01\u0e49\u0e2d\u0e22\u0e2d\u0e48\u0e30 \u0e01\u0e35\u0e48 bit \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e21\u0e35\u0e01\u0e35\u0e48\u0e40\u0e2b\u0e23\u0e35\u0e22\u0e0d \u0e41\u0e15\u0e48\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e40\u0e01\u0e47\u0e1a\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e19\u0e40\u0e2b\u0e23\u0e35\u0e0d\u0e40\u0e19\u0e2d\u0e30 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32\u0e40\u0e01\u0e47\u0e1a\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a Electronic \u0e01\u0e47\u0e43\u0e0a\u0e49 Flip-Flop \u0e41\u0e17\u0e19 1 bit Flip Flop \u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48\u0e23\u0e2d\u0e07\u0e40\u0e17\u0e49\u0e32","title":"Memory Function Types"},{"location":"memory/#electronic-memory-types","text":"\u0e41\u0e1a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 2 \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Volatile Memory \u0e40\u0e1b\u0e47\u0e19 Memory \u0e41\u0e1a\u0e1a\u0e17\u0e35\u0e48\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e2b\u0e32\u0e22\u0e40\u0e27\u0e25\u0e32\u0e44\u0e1f\u0e15\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e16\u0e39\u0e01\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Data Memory \u0e2b\u0e23\u0e37\u0e2d RAM \u0e41\u0e1a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e2d\u0e35\u0e01 DRAM SRAM Non-Volatile Memory \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e21\u0e48\u0e2b\u0e32\u0e22\u0e40\u0e27\u0e25\u0e32\u0e44\u0e1f\u0e15\u0e31\u0e14 \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e2b\u0e23\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19 Program Memory \u0e0b\u0e36\u0e48\u0e07\u0e2a\u0e21\u0e38\u0e22\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e23\u0e32\u0e23\u0e39\u0e49\u0e08\u0e31\u0e01\u0e01\u0e31\u0e19\u0e43\u0e19\u0e0a\u0e37\u0e48\u0e2d ROM (Read only memory) \u0e41\u0e1a\u0e48\u0e07\u0e44\u0e14\u0e49\u0e2d\u0e35\u0e01 ROM PROM EPROM EEPROM FLASH","title":"Electronic Memory Types"},{"location":"memory/#pointer","text":"","title":"Pointer"},{"location":"memory/#introduction","text":"\u0e40\u0e02\u0e49\u0e32\u0e43\u0e08\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e43\u0e19\u0e20\u0e32\u0e29\u0e32 C Pointer \u0e43\u0e0a\u0e49\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e04\u0e23\u0e31\u0e1a (\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07\u0e17\u0e35\u0e48\u0e27\u0e48\u0e32\u0e19\u0e35\u0e48\u0e04\u0e37\u0e2d\u0e17\u0e31\u0e49\u0e07\u0e23\u0e39\u0e49 Address \u0e41\u0e25\u0e30\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22\u0e19\u0e30) \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 Array \u0e01\u0e47\u0e40\u0e1b\u0e47\u0e19 Pointer \u0e16\u0e49\u0e32\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 int data[10] = {1,2,3,4,5,6,7,8,9,10}; int main(void){ printf(\"%d\",data); return 0; } \u0e16\u0e49\u0e32 printf(\"%d\",data); \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e04\u0e48\u0e32\u0e17\u0e31\u0e49\u0e07 Array \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e43\u0e19 JS \u0e2b\u0e23\u0e37\u0e2d Python \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e41\u0e15\u0e48\u0e08\u0e30\u0e44\u0e14\u0e49 Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e41\u0e23\u0e01\u0e2d\u0e2d\u0e01\u0e21\u0e32","title":"Introduction"},{"location":"memory/#defining-pointer","text":"\u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01 Array \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e35\u0e49\u0e41\u0e25\u0e49\u0e27\u0e22\u0e31\u0e07\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 Define Pointer \u0e44\u0e14\u0e49\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 \u0e42\u0e14\u0e22\u0e43\u0e2a\u0e48 * \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e0a\u0e37\u0e48\u0e2d\u0e41\u0e1b\u0e23 int *ptr; // define a pointer which points to data of type int \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Pointer \u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e23\u0e31\u0e1a\u0e40\u0e01\u0e47\u0e1a Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e01\u0e47\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16 Assign Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e19\u0e31\u0e49\u0e19\u0e44\u0e14\u0e49\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 \u0e2a\u0e31\u0e07\u0e40\u0e01\u0e15\u0e27\u0e48\u0e32\u0e40\u0e2d\u0e32 address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e44\u0e14\u0e49\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e43\u0e2a\u0e48 & \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 int datavariable=7; // define a variable called datavariable with value 7 int *ptr; // define a pointer which points to data of type int ptr = &datavariable;// assign the pointer to the address of datavariable \u0e2b\u0e23\u0e37\u0e2d\u0e08\u0e30\u0e40\u0e1b\u0e47\u0e19 Array \u0e41\u0e1a\u0e1a\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e35\u0e49 (\u0e01\u0e23\u0e13\u0e35\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49 Address \u0e02\u0e2d\u0e07 Element Array index \u0e17\u0e35\u0e48 0) int array[]={3,4,6,2,8,9,1,4,6}; // define an array of arbitrary values int *ptr // define a pointer ptr = &array[0]; // assign pointer to the address of the first element of the array","title":"Defining Pointer"},{"location":"memory/#pointers-with-array-and-functions","text":"/* Program Example 10.5: Pointers example for an array average function */ #include \"mbed.h\" Serial pc(USBTX, USBRX); // setup serial comms char data[]={5,7,5,8,9,1,7,8,2,5,1,4,6,2,1}; // define some input data char *dataptr; // define a pointer for the input data float average; // floating point average variable float CalculateAverage(char *ptr, char size); // function prototype int main() { dataptr=&data[0]; // point to address of the first array element average = CalculateAverage(dataptr, sizeof(data)); // call function pc.printf(\"\\n\\rdata = \"); for (char i=0; i<sizeof(data); i++) { // loop for each data value pc.printf(\"%d \",data[i]); // display all the data values } pc.printf(\"\\n\\raverage = %.3f\",average); // display average value } // CalculateAverage function definition and code float CalculateAverage(char *ptr, char size) { int sum=0; // variable for calculating the sum of the data float mean; // variable for floating point mean value for (char i=0; i<size; i++) { sum=sum + *(ptr+i); // add all data elements together } mean=(float)sum/size; // divide by size and cast to floating point return mean; } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e44\u0e2d\u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2a\u0e23\u0e49\u0e32\u0e07 function CalculateAverage \u0e42\u0e14\u0e22\u0e23\u0e31\u0e1a Address \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e41\u0e23\u0e01\u0e02\u0e2d\u0e07 array \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e1a size \u0e02\u0e2d\u0e07 Array \u0e17\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e04\u0e33\u0e19\u0e27\u0e19 (\u0e43\u0e0a\u0e48\u0e04\u0e23\u0e31\u0e1a \u0e43\u0e2a\u0e48 Array \u0e40\u0e02\u0e49\u0e32\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e2a\u0e48\u0e02\u0e19\u0e32\u0e14\u0e14\u0e49\u0e27\u0e22) \u0e41\u0e25\u0e30\u0e43\u0e19\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e44\u0e14\u0e49\u0e40\u0e2b\u0e47\u0e19\u0e01\u0e32\u0e23\u0e40\u0e2d\u0e32\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e08\u0e32\u0e01 Address \u0e19\u0e31\u0e49\u0e19 \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e32\u0e23 Dereferencing \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e2a\u0e48 * \u0e44\u0e27\u0e49\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 pointer","title":"Pointers with array and functions"},{"location":"memory/#files","text":"FILE *fopen(const char *filename, const char*mode); // \u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1b\u0e25\u0e4c int fclose(FILE *stream); // \u0e1b\u0e34\u0e14\u0e44\u0e1b\u0e25\u0e4c int fgetc(FILE *stream); // \u0e2d\u0e48\u0e32\u0e19 Character 1 \u0e15\u0e31\u0e27\u0e08\u0e32\u0e01\u0e44\u0e1f\u0e25\u0e4c char *fgets(char *str, int n, FILE *stream); // \u0e2d\u0e48\u0e32\u0e19 String \u0e08\u0e32\u0e01\u0e44\u0e1f\u0e25\u0e4c int fputc(int character, FILE *stream); // \u0e40\u0e02\u0e35\u0e22\u0e19 Character 1 \u0e15\u0e31\u0e27\u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fputs(const char *str, FILE *stream); // \u0e40\u0e02\u0e35\u0e22\u0e19 String \u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fprintf(FILE *stream, const char *format,...); // \u0e40\u0e02\u0e35\u0e22\u0e19 Formatted String \u0e25\u0e07\u0e44\u0e1f\u0e25\u0e4c int fseek(FILE *stream, long int offset, int origin); // \u0e40\u0e25\u0e37\u0e48\u0e2d\u0e19\u0e15\u0e33\u0e41\u0e2b\u0e19\u0e48\u0e07\u0e17\u0e35\u0e48\u0e08\u0e30\u0e2d\u0e48\u0e32\u0e19\u0e44\u0e1f\u0e25\u0e4c","title":"Files"},{"location":"memory/#using-data-files-on-the-mbed","text":"\u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 File \u0e43\u0e19 MBED \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 LocalFileSystem \u0e44\u0e14\u0e49 \u0e43\u0e0a\u0e49\u0e07\u0e35\u0e49 LocalFileSystem local(\"local\"); //Create file system named \"local\" \u0e17\u0e35\u0e19\u0e35\u0e49\u0e01\u0e47\u0e43\u0e0a\u0e49\u0e1f\u0e31\u0e07\u0e0a\u0e31\u0e19\u0e02\u0e2d\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e02\u0e49\u0e32\u0e07\u0e1a\u0e19\u0e44\u0e14\u0e49\u0e15\u0e32\u0e21\u0e1b\u0e01\u0e15\u0e34 FILE* pFile = fopen(\"/local/datafile.txt\",\"w\"); // note the \u201cw\u201d refers to a file with write access \u0e1e\u0e2d\u0e43\u0e0a\u0e49\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e01\u0e47\u0e1b\u0e34\u0e14 fclose(pFile); \u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07 /* Program Example 10.1: read and write char data bytes */ #include \"mbed.h\" Serial pc(USBTX,USBRX); // setup terminal link LocalFileSystem local(\"local\"); // define local file system int write_var; int read_var; // create data variables int main () { FILE* File1 = fopen(\"/local/datafile.txt\",\"w\"); // open file write_var=0x23; // example data fputc(write_var, File1); // put char (data value) into file fclose(File1); // close file FILE* File2 = fopen (\"/local/datafile.txt\",\"r\"); // open file for reading read_var = fgetc(File2); // read first data value fclose(File2); // close file pc.printf(\"input value = %i \\n\",read_var); // display read data value } \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1f\u0e25\u0e4c\u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e02\u0e35\u0e22\u0e19 character 1 \u0e15\u0e31\u0e27\u0e25\u0e07\u0e44\u0e1b /* Program Example 10.2: Read and write text string data */ #include \"mbed.h\" Serial pc(USBTX,USBRX); // setup terminal link LocalFileSystem local(\"local\"); // define local file system char write_string[64]; // character array up to 64 characters char read_string[64]; // create character arrays (strings) int main () { FILE* File1 = fopen(\"/local/textfile.txt\",\"w\"); // open file access fputs(\"lots and lots of words and letters\", File1);// put text into file fclose(File1); // close file FILE* File2 = fopen (\"/local/textfile.txt\",\"r\"); // open file for reading fgets(read_string,256,File2); // read text into variable fclose(File2); // close file pc.printf(\"text data: %s \\n\",read_string); // display read data string } \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e34\u0e14\u0e44\u0e1f\u0e25\u0e4c\u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e02\u0e35\u0e22\u0e19 string \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e25\u0e07\u0e44\u0e1b","title":"Using data files on the mbed"},{"location":"memory/#using-external-memory-with-the-mbed","text":"MBED \u0e15\u0e48\u0e2d Storage \u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e19\u0e30 \u0e15\u0e48\u0e2d\u0e44\u0e14\u0e49 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d SD Card \u0e2b\u0e23\u0e37\u0e2d USB Flashdrive \u0e16\u0e49\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 SD Card \u0e15\u0e48\u0e2d\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 SD Card connection table /* Program Example 10.4: writing data to an SD card */ #include \"mbed.h\" #include \"SDFileSystem.h\" SDFileSystem sd(p5, p6, p7, p8, \"sd\"); // MOSI, MISO, SCLK, CS Serial pc(USBTX, USBRX); int main() { FILE *File = fopen(\"/sd/sdfile.txt\", \"w\"); // open file if(File == NULL) { // check for file pointer pc.printf(\"Could not open file for write\\n\"); // error if no pointer } else{ pc.printf(\"SD card file successfully opened\\n\"); // if pointer ok } fprintf(File, \"Here's some sample text on the SD card\"); // write data fclose(File); // close file } \u0e44\u0e21\u0e48\u0e01\u0e47\u0e43\u0e0a\u0e49 External USB Flash Drive MBED \u0e1a\u0e2d\u0e14\u0e19\u0e35\u0e49\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 USB Host \u0e44\u0e14\u0e49 (\u0e40\u0e1e\u0e23\u0e32\u0e30 USB Builtin \u0e17\u0e35\u0e48\u0e02\u0e32 31,32) \u0e42\u0e14\u0e22 Library USBHostMSD /* Program Example 10.5: writing data to an USB flash storage device */ #include \"mbed.h\" #include \"USBHostMSD.h\" int main() { USBHostMSD usb(\"usb\"); // define USBHostMSD object while(!usb.connect()) { // try to connect a USB storage before continuing wait(0.5); printf(\"Connecting to USB MSD\\n\"); } FILE *File = fopen(\"/usb/usbfile.txt\", \"w\"); // open file if(File == NULL) { // check for file pointer intf(\"Could not open file for write\\n\"); // error if no pointer } else{ p tf(\"USB card file successfully opened\\n\"); // if pointer ok } fprintf(File, \"Here's some sample text on the USB card\"); // write data fclose(File); // close file }","title":"Using external memory with the mbed"},{"location":"midterm/","text":"Embeded System Midterm Chapter 1 : Embeded, MCU and ARM Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining Chapter 2 : Introducing to MBED \u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49) MBED Board Architecture LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } } Chapter 3 : Digital IO \u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a) \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs \u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO \u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49 7-Segment \u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 \\(I = 4mA\\) \\(V_{led} = 1.8V\\) \\(V_{pin} = 3.3V\\) \\(R_{internal} = 100\u03a9\\) \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3 - 1.8}{4m} - 100 = 275\u03a9\\) /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while } Control Larger Load \u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode Chapter 4 : Analog Output DAC (Digital to Analog Converter) Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22 PWM (Pulse Width Modulation) Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit PWM on MBED MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } } Servo Control \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32 Chapter 5 : Analog Input ADC (Analog to Digital Converter) Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error DAQ (Data Acquisition System) \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System Sampling Frequency and Aliasing Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14 Analog Input with mbed LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } } Display Value to the computer \u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 Simple Analog sensor LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!! Chapter 7 Serial Communication \u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link SPI (Serial Peripheral Interface) Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2193 \u0e25\u0e07 3 1 \u2191 \u0e02\u0e36\u0e49\u0e19 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } } SPI on mbed : Slave Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49 I2C (Inter-Integrated Circuit) I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07 I2C on mbed MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32 Asynchronous Serial \u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX) UART on mbed MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX) USB (Universal Serial Bus) \u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"Home"},{"location":"midterm/#embeded-system-midterm","text":"","title":"Embeded System Midterm"},{"location":"midterm/#chapter-1-embeded-mcu-and-arm","text":"Embeded system \u0e04\u0e37\u0e2d Product Controlled by Computer for Example Vending Machine Washing Machine Segway personal transporter MPU vs MCU MPU \u0e44\u0e21\u0e48\u0e1e\u0e39\u0e14\u0e16\u0e36\u0e07\u0e41\u0e15\u0e48 MCU \u0e04\u0e37\u0e2d Computer + Control Functions \u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22 Core Memory Peripheral Embeded uses C or C++ ARM (Advance RISC Machine Ltd.) \u0e40\u0e08\u0e49\u0e32\u0e19\u0e35\u0e49\u0e02\u0e32\u0e22 Processor IP \u0e41\u0e1a\u0e1a RISC (Reduced Instruction Set Computer) \u0e21\u0e35\u0e02\u0e49\u0e2d\u0e14\u0e35\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 1 binary word instruction instruction takes same amout of time Piplining","title":"Chapter 1 : Embeded, MCU and ARM"},{"location":"midterm/#chapter-2-introducing-to-mbed","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e40\u0e27\u0e23 MBED LPC1768 \u0e40\u0e1b\u0e47\u0e19 MCU \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e40\u0e2a\u0e23\u0e34\u0e21\u0e21\u0e32\u0e40\u0e23\u0e35\u0e22\u0e1a\u0e23\u0e49\u0e2d\u0e22\u0e41\u0e25\u0e49\u0e27 (\u0e40\u0e23\u0e35\u0e22\u0e01\u0e44\u0e14\u0e49\u0e27\u0e48\u0e32\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e43\u0e0a\u0e49)","title":"Chapter 2 : Introducing to MBED"},{"location":"midterm/#mbed-board-architecture","text":"LPC1768 MCU Signal Pins USB Interface MCU 16Mbit USB Disk (\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e08\u0e30\u0e2d\u0e31\u0e1e\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e1b\u0e01\u0e15\u0e34 \u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32 Compiled \u0e43\u0e2a\u0e48 USB Disk \u0e01\u0e47\u0e44\u0e14\u0e49) \u0e42\u0e04\u0e23\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 \u0e41\u0e15\u0e48\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e08\u0e33\u0e41\u0e21\u0e48\u0e07\u0e2b\u0e23\u0e2d\u0e01\u0e04\u0e23\u0e31\u0e1a /* Program Example 2.1: Simple LED flashing */ #include \"mbed.h\" DigitalOut myled(LED1); int main() { while(1) { myled = 1; wait(0.2); myled = 0; wait(0.2); } }","title":"MBED Board Architecture"},{"location":"midterm/#chapter-3-digital-io","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e14\u0e40\u0e27\u0e23\u0e19\u0e35\u0e48\u0e21\u0e35 26 Pin \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 Input \u0e41\u0e25\u0e30 Output \u0e44\u0e14\u0e49 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 Pin 5-30 \u0e42\u0e04\u0e49\u0e14\u0e21\u0e35\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 #include <mbed.h> // \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e01\u0e47 Include \u0e01\u0e48\u0e2d\u0e19 /** Digital IO */ DigitalOut myLED(LED1); DigitalIn myButton(btn1); BusIn busInput(P0,P1,P2); // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Input Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e23\u0e31\u0e1a\u0e04\u0e48\u0e32\u0e23\u0e31\u0e1a\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin BusOut busOutput(P0,P1,P2) // \u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e32\u0e22 Output Pin \u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e01\u0e31\u0e19 Up to 16 pins // \u0e15\u0e2d\u0e19\u0e2a\u0e31\u0e48\u0e07\u0e08\u0e30\u0e2a\u0e31\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 int \u0e17\u0e35\u0e48\u0e41\u0e15\u0e48\u0e25\u0e30 bit represent \u0e41\u0e15\u0e48\u0e25\u0e30 pin wait(s); wait_ms(ms); wait_us(us); Voltage as Logic values (GPIO \u0e02\u0e2d\u0e07\u0e0a\u0e34\u0e1e\u0e08\u0e23\u0e34\u0e07\u0e44\u0e21\u0e48\u0e21\u0e35 State Undefined \u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a)","title":"Chapter 3 : Digital IO"},{"location":"midterm/#leds","text":"\u0e2a\u0e23\u0e38\u0e1b\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e04\u0e37\u0e2d LED \u0e21\u0e31\u0e19\u0e23\u0e31\u0e1a \u0e01\u0e23\u0e30\u0e41\u0e2a \u0e44\u0e14\u0e49\u0e08\u0e33\u0e01\u0e31\u0e14\u0e0b\u0e36\u0e48\u0e07\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e08\u0e48\u0e32\u0e22\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e21\u0e32\u0e01\u0e40\u0e01\u0e34\u0e19\u0e44\u0e1b\u0e2d\u0e32\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e44\u0e2b\u0e25\u0e40\u0e01\u0e34\u0e19\u0e08\u0e19 LED \u0e02\u0e32\u0e14\u0e44\u0e14\u0e49 \u0e01\u0e32\u0e23\u0e08\u0e48\u0e32\u0e22\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e43\u0e2b\u0e49 LED \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2d\u0e22\u0e39\u0e48 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Source \u0e08\u0e30\u0e08\u0e48\u0e32\u0e22\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e02\u0e32 IO Sink \u0e08\u0e30\u0e14\u0e36\u0e07\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e19\u0e02\u0e32 IO","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07 LEDs"},{"location":"midterm/#switch-input","text":"Input \u0e41\u0e1a\u0e1a\u0e15\u0e48\u0e32\u0e07\u0e46 \u0e43\u0e0a\u0e49 Opto \u0e40\u0e1b\u0e47\u0e19 Input \u0e01\u0e47\u0e44\u0e14\u0e49","title":"\u0e27\u0e48\u0e32\u0e14\u0e49\u0e27\u0e22\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d Switch Input"},{"location":"midterm/#7-segment","text":"\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e04\u0e38\u0e49\u0e19\u0e40\u0e04\u0e22 \u0e43\u0e19 example \u0e43\u0e0a\u0e49 BusOut \u0e41\u0e15\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e42\u0e19\u0e49\u0e15\u0e44\u0e27\u0e49\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e36\u0e07\u0e27\u0e48\u0e32 Ouput Pin \u0e41\u0e15\u0e48\u0e25\u0e30 Pin \u0e21\u0e35\u0e04\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e15\u0e49\u0e32\u0e19\u0e17\u0e32\u0e19\u0e20\u0e32\u0e22\u0e43\u0e19 100\u03a9 \u0e41\u0e25\u0e30 LED Segment \u0e21\u0e35\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e15\u0e01\u0e04\u0e23\u0e48\u0e2d\u0e21\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13 1.8V \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e40\u0e27\u0e25\u0e32\u0e04\u0e33\u0e19\u0e27\u0e19\u0e01\u0e23\u0e30\u0e41\u0e2a\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e34\u0e14\u0e04\u0e48\u0e32 R \u0e20\u0e32\u0e22\u0e43\u0e19\u0e14\u0e49\u0e27\u0e22\u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 \\(I = 4mA\\) \\(V_{led} = 1.8V\\) \\(V_{pin} = 3.3V\\) \\(R_{internal} = 100\u03a9\\) \u0e14\u0e31\u0e07\u0e19\u0e31\u0e49\u0e19 R \u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3 - 1.8}{4m} - 100 = 275\u03a9\\) /*Program Example 3.7: Simple demonstration of 7-segment display. Display digits 0, 1, 2, 3 in turn. */ #include \"mbed.h\" BusOut display(p5,p6,p7,p8,p9,p10,p11,p12); // segments a,b,c,d,e,f,g,dp int main() { while(1) { for(int i=0; i<4; i++) { switch (i){ case 0: display = 0x3F; break; //display 0 case 1: display = 0x06; break; //display 1 case 2: display = 0x5B; break; case 3: display = 0x4F; break; } //end of switch wait(0.2); } //end of for } //end of while }","title":"7-Segment"},{"location":"midterm/#control-larger-load","text":"\u0e43\u0e0a\u0e49 BJT \u0e2b\u0e23\u0e37\u0e2d MOSFET Large Load Control \u0e41\u0e15\u0e48\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e23\u0e30\u0e27\u0e31\u0e07\u0e15\u0e2d\u0e19\u0e02\u0e31\u0e1a\u0e42\u0e2b\u0e25\u0e14\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19\u0e41\u0e1a\u0e1a Inductive ex. Motor \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32\u0e16\u0e49\u0e32\u0e15\u0e31\u0e14\u0e44\u0e1f\u0e08\u0e32\u0e01 Load \u0e1b\u0e23\u0e30\u0e40\u0e20\u0e17 Inductive \u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Back EMF \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19\u0e08\u0e33\u0e19\u0e27\u0e19\u0e21\u0e2b\u0e32\u0e28\u0e32\u0e25 \u0e0b\u0e36\u0e48\u0e07\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e17\u0e33\u0e25\u0e32\u0e22 Transistor \u0e2b\u0e23\u0e37\u0e2d MOSFET \u0e40\u0e23\u0e32\u0e44\u0e14\u0e49 Flyback Diode","title":"Control Larger Load"},{"location":"midterm/#chapter-4-analog-output","text":"","title":"Chapter 4 : Analog Output"},{"location":"midterm/#dac-digital-to-analog-converter","text":"Basicly convert binary input to analog output DAC Block Diagram Output Voltage of DAC are determined by \\(Vo = \\dfrac{D * V_{ref}}{2^n}\\) Vo : Output Voltage D : Digital Input Vref : Reference Voltage n : Number of bits In LPC1768 has 10-bit DAC \u0e01\u0e47\u0e04\u0e37\u0e2d \\(2^{10}\\) \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e47\u0e04\u0e37\u0e2d 1024 steps \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30 AnalogOut Example /*Program Example 4.1: Three values of DAC are output in turn on Pin 18. Read the output on a DVM. */ #include \"mbed.h\" AnalogOut Aout(p18); //create an analog output on pin 18 int main() { while(1) { Aout=0.25; // 0.25*3.3V = 0.825V wait(2); Aout=0.5; // 0.5*3.3V = 1.65V wait(2); Aout=0.75; // 0.75*3.3V = 2.475V wait(2); } } \u0e19\u0e2d\u0e01\u0e08\u0e32\u0e01\u0e19\u0e35\u0e49\u0e22\u0e31\u0e07\u0e21\u0e35 write write_u16 read \u0e41\u0e25\u0e30 Operator = \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e2d\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e04\u0e48\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 AnalogOut \u0e14\u0e49\u0e27\u0e22","title":"DAC (Digital to Analog Converter)"},{"location":"midterm/#pwm-pulse-width-modulation","text":"Basicly Square Wave with variable On-Time and the ratio of On:Off time is called Duty Cycle \u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Analog \u0e08\u0e32\u0e01 PWM \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e27\u0e07\u0e08\u0e23\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e09\u0e25\u0e35\u0e48\u0e22\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 Pulse \u0e44\u0e14\u0e49\u0e40\u0e0a\u0e48\u0e19 RC Low pass filter RC Lowpass filter circuit","title":"PWM (Pulse Width Modulation)"},{"location":"midterm/#pwm-on-mbed","text":"MBED LPC1768 has 6 PWM Output on pins 21-26 Functions Usage PwmOut Create Object write Set duty cycle 0.0-1.0 read Get current Duty Cycle period Set PWM Period in seconds period_ms Set PWM period in milliseconds period_us Set PWM period in microseconds pulsewidth Set PWM Pulse Width in seconds pulsewidth_ms Set PWM Pulse Width in milliseconds pulsewidth_us Set PWM Pulse Width in microseconds operator = Shorthand for write Example /*Sets PWM source to fixed frequency and duty cycle. Observe output on oscilloscope. */ #include \"mbed.h\" PwmOut PWM1(p21); //create a PWM output called PWM1 on pin 21 int main() { PWM1.period(0.010); // set PWM period to 10 ms PWM1=0.5; // set duty cycle to 50% } \u0e43\u0e0a\u0e49 Software Generated PWM \u0e01\u0e47\u0e44\u0e14\u0e49\u0e19\u0e30 /*Program Example 4.6: Software generated PWM. 2 PWM values generated in turn, with full on and off included for comparison. */ #include \"mbed.h\" DigitalOut motor(p6); int i; int main() { while(1) { motor = 0; //motor switched off for 5 secs wait (5); for (i=0;i<5000;i=i+1) { //5000 PWM cycles, low duty cycle motor = 1; wait_us(400); //output high for 400us motor = 0; wait_us(600); //output low for 600us } for (i=0;i<5000;i=i+1) { //5000 PWM cycles, high duty cycle motor = 1; wait_us(800); //output high for 800us motor = 0; wait_us(200); //output low for 200us } motor = 1; //motor switched fully on for 5 secs wait (5); } }","title":"PWM on MBED"},{"location":"midterm/#servo-control","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Control \u0e40\u0e1b\u0e47\u0e19 Pulse \u0e17\u0e35\u0e48\u0e21\u0e35 Period 20ms \u0e41\u0e25\u0e30 width \u0e15\u0e31\u0e49\u0e07\u0e41\u0e15\u0e48 1-2ms represent 0-180 \u0e2d\u0e07\u0e28\u0e32","title":"Servo Control"},{"location":"midterm/#chapter-5-analog-input","text":"","title":"Chapter 5 : Analog Input"},{"location":"midterm/#adc-analog-to-digital-converter","text":"Basicly Analog in Digital Out \u0e43\u0e0a\u0e49\u0e27\u0e31\u0e14\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e27\u0e31\u0e14\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a\u0e41\u0e23\u0e07\u0e14\u0e31\u0e19 Reference Voltage \u0e42\u0e14\u0e22\u0e17\u0e35\u0e48\u0e08\u0e30\u0e21\u0e35\u0e40\u0e2a\u0e1b\u0e04\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 1. Range is \u0e21\u0e31\u0e19\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e40\u0e22\u0e2d\u0e30\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 often minimum is 0V and Maximum value is \\(V_{ref}\\) 2. Resolution \u0e27\u0e31\u0e14\u0e44\u0e14\u0e49\u0e25\u0e30\u0e40\u0e2d\u0e35\u0e22\u0e14\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e1b\u0e01\u0e15\u0e34\u0e01\u0e47\u0e08\u0e33\u0e19\u0e27\u0e19\u0e40\u0e1b\u0e47\u0e19 bits \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32 10 bits \u0e01\u0e47\u0e08\u0e30\u0e27\u0e31\u0e14\u0e44\u0e14\u0e49 \\(2^{10} = 1024\\) Steps \u0e41\u0e25\u0e30\u0e01\u0e47\u0e40\u0e2d\u0e32\u0e21\u0e32\u0e40\u0e17\u0e35\u0e22\u0e1a\u0e01\u0e31\u0e1a Range \u0e01\u0e47\u0e08\u0e30\u0e44\u0e14\u0e49 Resolution = \\(\\dfrac{V_{ref}}{2^n}\\) 3. Quantisation \u0e04\u0e37\u0e2d Error \u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e04\u0e33\u0e19\u0e27\u0e19\u0e08\u0e32\u0e01 Resolution / 2 \u0e40\u0e0a\u0e48\u0e19 3.3V 8bit \u0e41\u0e15\u0e48\u0e25\u0e30 Step \u0e01\u0e47\u0e08\u0e30\u0e40\u0e17\u0e48\u0e32\u0e01\u0e31\u0e1a \\(\\dfrac{3.3}{256}=12.89mV\\) \u0e41\u0e25\u0e49\u0e27\u0e01\u0e47 \\(\\div2\\) \u0e08\u0e30\u0e44\u0e14\u0e49 \\(6.45mV\\) Quantisation Error","title":"ADC (Analog to Digital Converter)"},{"location":"midterm/#daq-data-acquisition-system","text":"\u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Environment \u0e17\u0e35\u0e48\u0e21\u0e32\u0e2d\u0e22\u0e39\u0e48\u0e23\u0e2d\u0e1a\u0e46 ADC \u0e40\u0e0a\u0e48\u0e19 - \u0e01\u0e48\u0e2d\u0e19\u0e08\u0e30\u0e27\u0e31\u0e14\u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e44\u0e1f\u0e1f\u0e49\u0e32\u0e0b\u0e30\u0e01\u0e48\u0e2d\u0e19 \u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 Transducer \u0e40\u0e0a\u0e48\u0e19 Microphone \u0e41\u0e1b\u0e25\u0e07\u0e08\u0e32\u0e01 Audio -> Electrical Signal - \u0e16\u0e49\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e2b\u0e25\u0e32\u0e22\u0e17\u0e35\u0e48\u0e43\u0e19\u0e23\u0e39\u0e1b\u0e08\u0e30\u0e21\u0e35 Multiplexer \u0e44\u0e27\u0e49\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e40\u0e02\u0e49\u0e32 Data Acquisition System","title":"DAQ (Data Acquisition System)"},{"location":"midterm/#sampling-frequency-and-aliasing","text":"Sampling Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e2d\u0e48\u0e32\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e16\u0e35\u0e48\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 \u0e08\u0e1a \u0e41\u0e25\u0e30\u0e01\u0e47\u0e21\u0e35 Nyquist Frequency \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35\u0e04\u0e48\u0e32\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e19\u0e49\u0e2d\u0e22 2 \u0e40\u0e17\u0e48\u0e32 \u0e02\u0e2d\u0e07\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e15\u0e49\u0e07\u0e01\u0e32\u0e23\u0e27\u0e31\u0e14","title":"Sampling Frequency and Aliasing"},{"location":"midterm/#analog-input-with-mbed","text":"LPC1768 has Single ADC with multiplexer and has reference voltage of 3.3V Functions Usage AnalogIn Create analog Object reead Read input voltage range from 0.0-1.0 read_u16 Read in unsigned short in the range (0x0 - 0xFFFF) Example /*This Program is basically a very slow Voltage Buffer */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20) //defines analog input on Pin 20 int main() { while(1) { Aout=Ain; //transfer analog in value to analog out, both } } /*Program Example 5.2: Uses analog input to control PWM duty cycle, fixed period */ #include \"mbed.h\" PwmOut PWM1(p23); AnalogIn Ain(p20); // defines analog input on Pin 20 int main() { while(1){ PWM1.period(0.010); // set PWM period to 10 ms PWM1=Ain; // Analog in value becomes PWM duty, // both are type float wait(0.1); } }","title":"Analog Input with mbed"},{"location":"midterm/#display-value-to-the-computer","text":"\u0e43\u0e0a\u0e49 Putty \u0e40\u0e16\u0e2d\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e1b\u0e34\u0e14 Serial Terminal Doesn't MACs has Putty? \u0e43\u0e0a\u0e49 Object Serial \u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 \u0e21\u0e35 Constant \u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e04\u0e37\u0e2d USBTX \u0e41\u0e25\u0e30 USBRX \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e32\u0e17\u0e35\u0e35\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a MCU \u0e17\u0e35\u0e48 Bridge \u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 USB \u0e01\u0e31\u0e1a LPC1768 /*Program Example 5.4: Reads input voltage through the ADC, and transfers to PC terminal */ #include \"mbed.h\" Serial pc(USBTX, USBRX); //enable serial port which links to USB AnalogIn Ain(p20); float ADCdata; int main() { pc.printf(\"ADC Data Values...\\n\\r\"); //send an opening text message while(1){ ADCdata=Ain; wait(0.5); pc.printf(\"%1.3f \\n\\r\",ADCdata); //send the data to the terminal } } \u0e01\u0e32\u0e23\u0e1b\u0e23\u0e34\u0e49\u0e19\u0e04\u0e48\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 pc.printf(\"abc %d\",variable) \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22","title":"Display Value to the computer"},{"location":"midterm/#simple-analog-sensor","text":"LDR Sensor LM35 Temperature Sensor Exploring Conversion Timing /*Program Example 5.5: Inputs signal through ADC, and outputs to DAC. View DAC output on oscilloscope. To demonstrate Nyquist, connect variable frequency signal generator to ADC input. Allows measurement of conversion times, and explores Nyquist limit. */ #include \"mbed.h\" AnalogOut Aout(p18); //defines analog output on Pin 18 AnalogIn Ain(p20); //defines analog input on Pin 20 DigitalOut test(p5); float ADCdata; int main() { while(1) { ADCdata=Ain; //starts A-D conversion, and assigns analog value to ADCdata test=1; //switch test output, as time marker test=0; Aout=ADCdata; // transfers stored value to DAC, and forces a D-A conversion test=1; //a double pulse, to mark the end of conversion test=0; test=1; test=0; //wait(0.001); //optional wait state, to explore different cycle times } } \u0e40\u0e2d\u0e32\u0e07\u0e48\u0e32\u0e22\u0e46\u0e40\u0e25\u0e22 \u0e42\u0e04\u0e49\u0e14\u0e19\u0e35\u0e49\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32 Analog \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23 \u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 1 pulse \u0e41\u0e25\u0e49\u0e27\u0e40\u0e2d\u0e32\u0e04\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e44\u0e1b\u0e40\u0e02\u0e49\u0e32 DAC \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e01\u0e23\u0e30\u0e1e\u0e23\u0e34\u0e1a 2 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e48\u0e32\u0e19\u0e43\u0e2b\u0e21\u0e48 \u0e41\u0e25\u0e49\u0e27\u0e17\u0e33\u0e44\u0e21\u0e44\u0e21\u0e48\u0e08\u0e48\u0e32\u0e22 High \u0e15\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Low \u0e15\u0e2d\u0e19\u0e08\u0e1a\u0e27\u0e30!!!","title":"Simple Analog sensor"},{"location":"midterm/#chapter-7-serial-communication","text":"\u0e21\u0e31\u0e19 Serial (\u0e2d\u0e19\u0e38\u0e01\u0e23\u0e21) \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e31\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e25\u0e30 1 bit \u0e16\u0e36\u0e07\u0e08\u0e30\u0e0a\u0e49\u0e32\u0e01\u0e27\u0e48\u0e32 Parallel \u0e41\u0e15\u0e48\u0e01\u0e47\u0e14\u0e35\u0e01\u0e27\u0e48\u0e32\u0e43\u0e19\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e32\u0e22\u0e19\u0e49\u0e2d\u0e22 \u0e21\u0e35 2 \u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2d Synchronous \u0e01\u0e31\u0e1a Asynchronous Serial Asynchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial Link \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e49\u0e27\u0e2d\u0e32\u0e28\u0e31\u0e22\u0e01\u0e32\u0e23\u0e19\u0e31\u0e1a Timing \u0e02\u0e2d\u0e07\u0e1d\u0e31\u0e48\u0e07\u0e2a\u0e48\u0e07\u0e41\u0e25\u0e30\u0e1d\u0e31\u0e48\u0e07\u0e23\u0e31\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19 Synchronous Serial \u0e01\u0e47\u0e04\u0e37\u0e2d Serial \u0e17\u0e35\u0e48\u0e21\u0e35 clock \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Synchroni z ed Frame \u0e02\u0e2d\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Basics of Serial Port : the shift register \u0e08\u0e23\u0e34\u0e07\u0e46\u0e01\u0e47\u0e41\u0e04\u0e48\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock \u0e41\u0e25\u0e30 Data \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e25\u0e49\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 Parallel Serial in Parallel Out A Simple Serial Link \u0e2d\u0e31\u0e19\u0e19\u0e35\u0e49\u0e04\u0e37\u0e2d Synchronous Link \u0e17\u0e35\u0e48\u0e21\u0e35\u0e41\u0e04\u0e48 Clock, TX (SDO), RX(SDI) \u0e1b\u0e01\u0e15\u0e34\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01\u0e02\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e23\u0e31\u0e1a \u0e41\u0e25\u0e30\u0e08\u0e32\u0e01\u0e02\u0e32\u0e23\u0e31\u0e1a\u0e44\u0e1b\u0e2a\u0e48\u0e07\u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 Role \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e2d Slave \u0e01\u0e31\u0e1a Master \u0e0b\u0e36\u0e48\u0e07\u0e01\u0e47\u0e15\u0e48\u0e32\u0e07\u0e01\u0e31\u0e19\u0e41\u0e04\u0e48 Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19 Generate \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13 Clock (\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e16\u0e49\u0e32 Master \u0e44\u0e21\u0e48\u0e16\u0e32\u0e21 Slave \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e1e\u0e39\u0e14\u0e14\u0e14) Simple Serial Link","title":"Chapter 7 Serial Communication"},{"location":"midterm/#spi-serial-peripheral-interface","text":"Created by Motorola and National Semiconductors \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e21\u0e35 Clock, Data In, Data Out \u0e41\u0e25\u0e30 Slave Select (SS) \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35 Slave \u0e01\u0e35\u0e48\u0e15\u0e31\u0e27\u0e01\u0e47\u0e15\u0e48\u0e2d SS \u0e44\u0e1b\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19\u0e40\u0e25\u0e22\u0e2d\u0e48\u0e30\u0e19\u0e30 SPI on mbed : Master MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 Function Usage SPI(mosi, miso, sclk) Create SPI Master and configure the Pin format(bit,mode) configure data mode and data length frequency(hz) Set SPI Clock Frequency write(data) Write to the SPI Slave and return the response \u0e1b\u0e01\u0e15\u0e34 SPI \u0e08\u0e30\u0e21\u0e35 Mode \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e2d\u0e22\u0e39\u0e48 4 \u0e42\u0e2b\u0e21\u0e14 (\u0e42\u0e2b\u0e21\u0e14\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2d\u0e48\u0e32\u0e19\u0e17\u0e35\u0e48\u0e02\u0e32\u0e02\u0e36\u0e49\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e07 \u0e41\u0e25\u0e30\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32 Idle Clock \u0e40\u0e1b\u0e47\u0e19 High \u0e2b\u0e23\u0e37\u0e2d Low) \u0e16\u0e49\u0e32\u0e43\u0e2b\u0e49\u0e08\u0e33\u0e07\u0e48\u0e32\u0e22\u0e46 Mode Idle Clock \u0e2d\u0e48\u0e32\u0e19\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e15\u0e2d\u0e19\u0e44\u0e2b\u0e19 0 0 \u2191 \u0e02\u0e36\u0e49\u0e19 1 0 \u2193 \u0e25\u0e07 2 1 \u2193 \u0e25\u0e07 3 1 \u2191 \u0e02\u0e36\u0e49\u0e19 SPI Master Example #include \"mbed.h\" SPI ser_port(p11, p12, p13); // mosi, miso, sclk char switch_word ; //word we will send int main() { ser_port.format(8,0); // Setup the SPI for 8 bit data, Mode 0 operation ser_port.frequency(1000000); // Clock frequency is 1MHz while (1){ switch_word = 0xA1; //set up word to be transmitted int readBack = ser_port.write(switch_word); //send switch_word and read in readBack wait_us(50); } }","title":"SPI (Serial Peripheral Interface)"},{"location":"midterm/#spi-on-mbed-slave","text":"Functions Usage SPISlave(mosi,miso,sck,ss) Create a SPI slave connected to the specified pins format(bit,mode) Configure the data transmission format frequency(hz) Set clock Frequency (\u0e40\u0e1e\u0e37\u0e48\u0e2d?) receive() Flag \u0e27\u0e48\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e21\u0e32\u0e21\u0e31\u0e49\u0e22 read() Return data reply() \u0e16\u0e49\u0e32\u0e23\u0e2d\u0e1a\u0e2b\u0e19\u0e49\u0e32 Master \u0e17\u0e31\u0e01\u0e21\u0e32\u0e08\u0e30\u0e15\u0e2d\u0e1a\u0e27\u0e48\u0e32\u0e44\u0e07\u0e21\u0e31\u0e49\u0e22 ADXL345 Accelerometer Evaluating SPI \u0e02\u0e49\u0e2d\u0e14\u0e35 \u0e40\u0e23\u0e47\u0e27 \u0e16\u0e39\u0e01 \u0e21\u0e35\u0e1b\u0e23\u0e30\u0e2a\u0e34\u0e17\u0e18\u0e34\u0e20\u0e32\u0e1e \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23 Ack \u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e27\u0e48\u0e32\u0e2a\u0e48\u0e07\u0e44\u0e1b\u0e40\u0e02\u0e32\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e04\u0e23\u0e1a\u0e16\u0e39\u0e01\u0e21\u0e31\u0e49\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35 Addressing \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 SS Line \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e17\u0e38\u0e01 Slave \u0e44\u0e21\u0e48\u0e21\u0e35 Error Checking \u0e01\u0e47\u0e16\u0e49\u0e32\u0e21\u0e35\u0e01\u0e32\u0e23\u0e23\u0e1a\u0e01\u0e27\u0e19\u0e04\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e21\u0e35\u0e17\u0e32\u0e07\u0e23\u0e39\u0e49","title":"SPI on mbed : Slave"},{"location":"midterm/#i2c-inter-integrated-circuit","text":"I2C \u0e40\u0e1b\u0e47\u0e19 Serial \u0e41\u0e1a\u0e1a Master/Slave \u0e2d\u0e22\u0e39\u0e48 \u0e21\u0e35\u0e2a\u0e32\u0e22 2 \u0e40\u0e2a\u0e49\u0e19\u0e04\u0e37\u0e2d SCL/SDA (Clock, Data) \u0e41\u0e1a\u0e1a Open-Collector \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e21\u0e35 Pullup Resistor \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e41\u0e15\u0e48\u0e25\u0e30 Node \u0e08\u0e30 Force Bus \u0e40\u0e1b\u0e47\u0e19 0 \u0e44\u0e14\u0e49\u0e41\u0e15\u0e48 Force \u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e47\u0e19 1 \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e30\u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e1e\u0e2d\u0e40\u0e1b\u0e47\u0e19 Master/Slave \u0e01\u0e47\u0e08\u0e30\u0e17\u0e33\u0e43\u0e2b\u0e49 Master \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21 Transfer data (Master \u0e44\u0e21\u0e48\u0e02\u0e2d\u0e01\u0e47\u0e43\u0e2b\u0e49 Slave \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e07\u0e35\u0e22\u0e1a\u0e46) Start Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2193 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High Stop Condition \u0e40\u0e23\u0e34\u0e48\u0e21\u0e15\u0e2d\u0e19 SDA\u2191 \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 SCL \u0e22\u0e31\u0e07 High \u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e40\u0e23\u0e34\u0e48\u0e21\u0e14\u0e49\u0e27\u0e22 (7-bits) Address \u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e49\u0e27\u0e15\u0e32\u0e21\u0e14\u0e49\u0e27\u0e22 \\(Read/\\overline{Write}\\) Bit \u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19 Slave \u0e08\u0e30 ACK \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25 Address \u0e02\u0e2d\u0e07 I2C \u0e40\u0e1b\u0e47\u0e19 Address \u0e41\u0e1a\u0e1a 7 bits \u0e41\u0e15\u0e48\u0e15\u0e2d\u0e19\u0e2a\u0e48\u0e07\u0e15\u0e49\u0e2d\u0e07 left shift \u0e44\u0e1b 1 (\u0e40\u0e1e\u0e37\u0e48\u0e2d Reserved Bit \u0e0b\u0e49\u0e32\u0e22\u0e2a\u0e38\u0e14\u0e44\u0e27\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a \\(R/\\overline{W}\\) \u0e22\u0e31\u0e07\u0e44\u0e07\u0e25\u0e48\u0e30) \u0e1b\u0e01\u0e15\u0e34\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Byte \u0e08\u0e30\u0e2a\u0e48\u0e07\u0e01\u0e35\u0e48 Byte \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e44\u0e21\u0e48\u0e21\u0e35 Limit \u0e41\u0e15\u0e48\u0e08\u0e30\u0e21\u0e35 1 bit acknowledge \u0e17\u0e38\u0e01 Byte \u0e17\u0e35\u0e48\u0e2a\u0e48\u0e07","title":"I2C (Inter-Integrated Circuit)"},{"location":"midterm/#i2c-on-mbed","text":"MBED \u0e21\u0e35 SPI \u0e2d\u0e22\u0e39\u0e48 2 Port \u0e42\u0e14\u0e22\u0e41\u0e15\u0e48\u0e25\u0e30\u0e2d\u0e31\u0e19\u0e08\u0e30\u0e15\u0e31\u0e49\u0e07\u0e40\u0e1b\u0e47\u0e19 Master \u0e2b\u0e23\u0e37\u0e2d Slave \u0e01\u0e47\u0e44\u0e14\u0e49 I2C Function (\u0e41\u0e04\u0e1b\u0e25\u0e30\u0e01\u0e31\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e44\u0e21\u0e48\u0e44\u0e2b\u0e27\u0e25\u0e30) uint8_t address; // Slave Address I2C i2c_port(p9, p10); // P9 = SDA, P10 = SCL // \u0e16\u0e49\u0e32\u0e08\u0e30 Write \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1); i2c_port.write(data); i2c_port.stop(); // \u0e16\u0e49\u0e32\u0e08\u0e30 Read \u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 i2c_port.start(); i2c_port.write(address << 1 | 0x01); // \u0e15\u0e49\u0e2d\u0e07\u0e40\u0e15\u0e34\u0e21 1 \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e17\u0e49\u0e32\u0e22 address \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e30\u0e1a\u0e38\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 Read int read = i2c_port.read(); // \u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e2b\u0e25\u0e32\u0e22 Byte \u0e01\u0e47 For \u0e40\u0e2d\u0e32\u0e21\u0e31\u0e49\u0e07555 i2c_port.stop(); \u0e02\u0e49\u0e2d\u0e14\u0e35\u0e04\u0e37\u0e2d Reliable \u0e02\u0e49\u0e2d\u0e40\u0e2a\u0e35\u0e22\u0e04\u0e37\u0e2d \u0e0a\u0e49\u0e32","title":"I2C on mbed"},{"location":"midterm/#asynchronous-serial","text":"\u0e14\u0e49\u0e27\u0e22\u0e04\u0e27\u0e32\u0e21 Asynchronous \u0e41\u0e19\u0e48\u0e19\u0e2d\u0e19 \u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23 Clock \u0e41\u0e15\u0e48\u0e04\u0e27\u0e32\u0e21\u0e40\u0e23\u0e47\u0e27\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e01\u0e25\u0e07\u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e19\u0e30 \u0e44\u0e21\u0e48\u0e07\u0e31\u0e49\u0e19\u0e04\u0e38\u0e22\u0e01\u0e31\u0e19\u0e44\u0e21\u0e48\u0e23\u0e39\u0e49\u0e40\u0e23\u0e37\u0e48\u0e2d\u0e07 \u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30 Byte/Word \u0e08\u0e30\u0e21\u0e35 Start \u0e41\u0e25\u0e30 Stop Bit \u0e01\u0e32\u0e23\u0e2a\u0e37\u0e48\u0e2d\u0e32\u0e23\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e35\u0e22\u0e01\u0e27\u0e48\u0e32 UART (Universla Asynchronous Receiver/Transmitter) \u0e21\u0e35\u0e2a\u0e32\u0e22 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07(TX) \u0e41\u0e25\u0e30 1 \u0e40\u0e2a\u0e49\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e23\u0e31\u0e1a(RX)","title":"Asynchronous Serial"},{"location":"midterm/#uart-on-mbed","text":"MBED \u0e21\u0e35 UART \u0e2d\u0e22\u0e39\u0e48 4 \u0e0a\u0e48\u0e2d\u0e07\u0e15\u0e32\u0e21\u0e19\u0e35\u0e49 (\u0e2d\u0e31\u0e19\u0e17\u0e35\u0e48\u0e40\u0e02\u0e35\u0e22\u0e19\u0e27\u0e48\u0e32 Serial) \u0e16\u0e49\u0e32\u0e08\u0e30\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a PC \u0e08\u0e30\u0e21\u0e35 Constant \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e43\u0e19 Serial \u0e44\u0e14\u0e49\u0e04\u0e37\u0e2d USBTX USBRX \u0e01\u0e47\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e1b\u0e23\u0e30\u0e21\u0e32\u0e13\u0e19\u0e35\u0e49 Serial pc(USBTX,USBRX)","title":"UART on mbed"},{"location":"midterm/#usb-universal-serial-bus","text":"\u0e01\u0e47\u0e15\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d Universal \u0e16\u0e2d\u0e14\u0e40\u0e2a\u0e35\u0e22\u0e1a\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\u0e2d\u0e30\u0e44\u0e23 (Plug and Play) \u0e1a\u0e2d\u0e23\u0e4c\u0e14 MBED \u0e21\u0e35 USB 2 Port \u0e41\u0e15\u0e48\u0e21\u0e35 Peripheral \u0e41\u0e04\u0e48\u0e1e\u0e2d\u0e23\u0e4c\u0e15\u0e40\u0e14\u0e35\u0e22\u0e27\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e2d\u0e31\u0e19\u0e19\u0e36\u0e07\u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21,\u0e08\u0e48\u0e32\u0e22\u0e44\u0e1f\u0e41\u0e25\u0e30 Serial \u0e2a\u0e48\u0e27\u0e19\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e40\u0e1b\u0e47\u0e19 USB Device \u0e44\u0e14\u0e49 USB \u0e17\u0e33\u0e15\u0e31\u0e27\u0e40\u0e1b\u0e47\u0e19 Mouse, Keyboard, Serial, MIDI, Audio, USBMSD","title":"USB (Universal Serial Bus)"},{"location":"wireless/","text":"Chapter 11 Wireless Communication - Bluetooth and ZigBee Wireless Preliminary \u0e21\u0e31\u0e19\u0e21\u0e35\u0e2a\u0e39\u0e15\u0e23 \\(v=f\\lambda\\) \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e04\u0e33\u0e19\u0e27\u0e19\u0e44\u0e14\u0e49 \u0e25\u0e30\u0e01\u0e47\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e21\u0e35\u0e04\u0e19\u0e04\u0e38\u0e21\u0e2d\u0e22\u0e39\u0e48\u0e04\u0e37\u0e2d Internation Telecommunication Union \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e43\u0e19\u0e2b\u0e21\u0e27\u0e14\u0e2b\u0e21\u0e39\u0e48 Industrial, Scientific and Medical (ISM) \u0e17\u0e35\u0e48\u0e04\u0e19\u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e44\u0e14\u0e49 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e27\u0e34\u0e17\u0e22\u0e38\u0e08\u0e30\u0e21\u0e35\u0e1b\u0e23\u0e30\u0e42\u0e22\u0e0a\u0e19\u0e4c\u0e01\u0e47\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e1c\u0e48\u0e32\u0e19\u0e21\u0e31\u0e19\u0e44\u0e14\u0e49\u0e41\u0e2b\u0e25\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e23\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e02\u0e31\u0e49\u0e19\u0e15\u0e2d\u0e19\u0e01\u0e32\u0e23\u0e22\u0e31\u0e14\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e2a\u0e49\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e27\u0e34\u0e17\u0e22\u0e38\u0e19\u0e35\u0e49\u0e27\u0e48\u0e32 modulation \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e01\u0e32\u0e23 Modulation \u0e17\u0e35\u0e48\u0e27\u0e48\u0e32\u0e40\u0e19\u0e35\u0e48\u0e22\u0e21\u0e31\u0e19\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e41\u0e1b\u0e25\u0e07\u0e44\u0e14\u0e49 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e21\u0e31\u0e19\u0e08\u0e30\u0e21\u0e35 Bandwidth \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19 \u0e0a\u0e48\u0e27\u0e07 \u0e02\u0e2d\u0e07\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e17\u0e35\u0e48\u0e08\u0e30\u0e23\u0e31\u0e1a\u0e42\u0e14\u0e22\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e23\u0e31\u0e1a \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e23\u0e31\u0e1a\u0e15\u0e31\u0e49\u0e07\u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e23\u0e31\u0e1a\u0e17\u0e35\u0e48 103MHz (\u0e02\u0e36\u0e49\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a\u0e27\u0e34\u0e18\u0e35\u0e01\u0e32\u0e23 Modulation)\u0e01\u0e47\u0e08\u0e30\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e2a\u0e39\u0e07\u0e41\u0e25\u0e30\u0e15\u0e48\u0e33\u0e01\u0e27\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e17\u0e35\u0e48\u0e15\u0e31\u0e49\u0e07\u0e44\u0e27\u0e49\u0e19\u0e34\u0e14\u0e2b\u0e19\u0e48\u0e2d\u0e22 \u0e21\u0e32\u0e01\u0e19\u0e49\u0e2d\u0e22\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e02\u0e36\u0e49\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a\u0e27\u0e48\u0e32 Bandwidth \u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48 Wireless Network Personal Area Network (PAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e43\u0e01\u0e25\u0e49\u0e04\u0e19 Local Area Network (LAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e41\u0e04\u0e48\u0e43\u0e19\u0e2d\u0e32\u0e04\u0e32\u0e23 Wide Area Network (EAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e31\u0e48\u0e27\u0e2d\u0e48\u0e30 Protocols International Organi z ation for Standardi z ation (ISO) \u0e44\u0e14\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14 Protocol for Protocols \u0e44\u0e27\u0e49\u0e40\u0e1b\u0e47\u0e19 Open Systems Interconnect \u0e2b\u0e23\u0e37\u0e2d OSI model OSI Model Protocol - IEEE Woring groups IEEE \u0e04\u0e19\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e21\u0e32\u0e15\u0e23\u0e10\u0e32\u0e19\u0e43\u0e2b\u0e49\u0e01\u0e31\u0e1a protocol \u0e15\u0e48\u0e32\u0e07\u0e46\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a network \u0e42\u0e14\u0e22\u0e08\u0e30\u0e02\u0e36\u0e49\u0e19\u0e14\u0e49\u0e27\u0e22 802. IEEE Woring Group Description 802.3 Ethernet 802.11 Wireless LAN, including Wi-Fi 802.15 Wireless PAN 802.15.1 Bluetooth 802.15.3 High-rate wireless PAN 802.15.4 Low-rate wireless PAN, e.g. Zigbee Bluetooth \u0e40\u0e1b\u0e47\u0e19 Digital Radio Protocol \u0e43\u0e0a\u0e49\u0e43\u0e19 Network \u0e41\u0e1a\u0e1a PAN \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e01\u0e31\u0e1a\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c Bluetooth Characterisics Class Range Power 1 100 meters 100mW 2 10 meters 2.5mW 3 1 meters 1mW \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c BT \u0e41\u0e15\u0e48\u0e25\u0e30\u0e15\u0e31\u0e27\u0e21\u0e35 Unique MAC Address (\u0e2b\u0e23\u0e2d\u0e27\u0e30!!) \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35 Phase \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 1. Discovery \u0e01\u0e47\u0e04\u0e37\u0e2d Broadcast \u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e17\u0e31\u0e49\u0e07\u0e0a\u0e37\u0e48\u0e2d\u0e41\u0e25\u0e30 MAC Address 1. Pairing \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e17\u0e31\u0e49\u0e07 Slave \u0e41\u0e25\u0e30 Master \u0e41\u0e25\u0e01\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e27\u0e48\u0e32\u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e07 1. Connecting \u0e01\u0e47\u0e04\u0e37\u0e2d Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e1b\u0e34\u0e14\u0e08\u0e32\u0e01 Link \u0e17\u0e35\u0e48\u0e44\u0e14\u0e49 Pair \u0e01\u0e31\u0e19\u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27 RN-41 Bluetooth Module with MBED \u0e43\u0e0a\u0e49\u0e42\u0e21\u0e14\u0e39\u0e25 RN-41 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Class 1 \u0e14\u0e49\u0e27\u0e22\u0e41\u0e25\u0e30\u0e01\u0e47\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Bluetooth \u0e02\u0e2d\u0e07 \u0e42\u0e19\u0e49\u0e15\u0e1a\u0e38\u0e4a\u0e15\u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 \u0e2a\u0e48\u0e27\u0e19\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a MBED \u0e1c\u0e48\u0e32\u0e19 UART Serial \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e27\u0e34\u0e18\u0e35\u0e43\u0e0a\u0e49\u0e44\u0e21\u0e48\u0e15\u0e48\u0e32\u0e07\u0e2d\u0e30\u0e44\u0e23\u0e01\u0e31\u0e1a Serial \u0e40\u0e25\u0e22 Bluetooth Module Connection ZigBee \u0e43\u0e0a\u0e49 Standard IEEE 802.15.4 \u0e15\u0e31\u0e27\u0e19\u0e35\u0e49\u0e04\u0e25\u0e49\u0e32\u0e22 Bluetooth \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35\u0e01\u0e32\u0e23 Pair \u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e19\u0e41\u0e15\u0e48\u0e27\u0e48\u0e32\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32 \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32(\u0e21\u0e32\u0e01\u0e46) \u0e41\u0e25\u0e30\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22(\u0e19\u0e49\u0e2d\u0e22\u0e0a\u0e34\u0e1a\u0e2b\u0e32\u0e22) \u0e40\u0e1b\u0e49\u0e32\u0e2b\u0e21\u0e32\u0e22\u0e40\u0e02\u0e32\u0e04\u0e37\u0e2d\u0e16\u0e39\u0e01\u0e27\u0e48\u0e32 (\u0e2b\u0e23\u0e32\u0e32 \u0e41\u0e1e\u0e07\u0e2a\u0e31\u0e2a\u0e40\u0e25\u0e22) \u0e07\u0e48\u0e32\u0e22\u0e01\u0e27\u0e48\u0e32\u0e41\u0e25\u0e30\u0e21\u0e35 Overhead \u0e02\u0e2d\u0e07 Software \u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32 Zigbee Device Types End Device \u0e40\u0e1b\u0e47\u0e19\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e1b\u0e25\u0e32\u0e22\u0e17\u0e32\u0e07 \u0e08\u0e30\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a\u0e41\u0e04\u0e48 Parent (\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Router \u0e2b\u0e23\u0e37\u0e2d Coordinator) \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19 Router \u0e43\u0e0a\u0e49 route traffic \u0e43\u0e0a\u0e49\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 End Device \u0e01\u0e31\u0e1a Coordinator \u0e44\u0e14\u0e49 Coordinator \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e04\u0e38\u0e21\u0e40\u0e04\u0e23\u0e37\u0e2d\u0e02\u0e48\u0e32\u0e22 \u0e01\u0e33\u0e2b\u0e19\u0e14 Characteristic \u0e02\u0e2d\u0e07 Network \u0e14\u0e49\u0e27\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 XBee Wireless Modules \u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e2d\u0e07 Digi International XBee Module \u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e04\u0e2d\u0e21\u0e44\u0e21\u0e48\u0e21\u0e35 Zigbee \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e31\u0e19\u0e02\u0e27\u0e32\u0e0a\u0e48\u0e27\u0e22 \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e15\u0e48\u0e2d Module Zigbee \u0e40\u0e02\u0e49\u0e32\u0e04\u0e2d\u0e21\u0e41\u0e25\u0e30\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 XCTU \u0e40\u0e1e\u0e37\u0e48\u0e2d Config XBee Module XBee Module Implementing a Zigbee Link mbed to mbed XBee Module with MBED \u0e15\u0e48\u0e2d\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bluetooth \u0e43\u0e0a\u0e49\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bluetooth \u0e40\u0e25\u0e22 (\u0e16\u0e49\u0e32\u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a\u0e04\u0e2d\u0e21) \u0e17\u0e35\u0e48\u0e40\u0e2b\u0e25\u0e37\u0e2d\u0e02\u0e2d\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15 \u0e0a\u0e48\u0e32\u0e07\u0e41\u0e21\u0e48\u0e21","title":"Chapter 11"},{"location":"wireless/#chapter-11-wireless-communication-bluetooth-and-zigbee","text":"","title":"Chapter 11 Wireless Communication - Bluetooth and ZigBee"},{"location":"wireless/#wireless-preliminary","text":"\u0e21\u0e31\u0e19\u0e21\u0e35\u0e2a\u0e39\u0e15\u0e23 \\(v=f\\lambda\\) \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e04\u0e33\u0e19\u0e27\u0e19\u0e44\u0e14\u0e49 \u0e25\u0e30\u0e01\u0e47\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e21\u0e35\u0e04\u0e19\u0e04\u0e38\u0e21\u0e2d\u0e22\u0e39\u0e48\u0e04\u0e37\u0e2d Internation Telecommunication Union \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e43\u0e19\u0e2b\u0e21\u0e27\u0e14\u0e2b\u0e21\u0e39\u0e48 Industrial, Scientific and Medical (ISM) \u0e17\u0e35\u0e48\u0e04\u0e19\u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49\u0e44\u0e14\u0e49 \u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e27\u0e34\u0e17\u0e22\u0e38\u0e08\u0e30\u0e21\u0e35\u0e1b\u0e23\u0e30\u0e42\u0e22\u0e0a\u0e19\u0e4c\u0e01\u0e47\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e1c\u0e48\u0e32\u0e19\u0e21\u0e31\u0e19\u0e44\u0e14\u0e49\u0e41\u0e2b\u0e25\u0e30\u0e04\u0e23\u0e31\u0e1a \u0e40\u0e23\u0e32\u0e40\u0e23\u0e35\u0e22\u0e01\u0e02\u0e31\u0e49\u0e19\u0e15\u0e2d\u0e19\u0e01\u0e32\u0e23\u0e22\u0e31\u0e14\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e2a\u0e49\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e27\u0e34\u0e17\u0e22\u0e38\u0e19\u0e35\u0e49\u0e27\u0e48\u0e32 modulation \u0e0b\u0e36\u0e48\u0e07\u0e44\u0e2d\u0e01\u0e32\u0e23 Modulation \u0e17\u0e35\u0e48\u0e27\u0e48\u0e32\u0e40\u0e19\u0e35\u0e48\u0e22\u0e21\u0e31\u0e19\u0e17\u0e33\u0e43\u0e2b\u0e49\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e21\u0e35\u0e01\u0e32\u0e23\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e41\u0e1b\u0e25\u0e07\u0e44\u0e14\u0e49 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e21\u0e31\u0e19\u0e08\u0e30\u0e21\u0e35 Bandwidth \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19 \u0e0a\u0e48\u0e27\u0e07 \u0e02\u0e2d\u0e07\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e17\u0e35\u0e48\u0e08\u0e30\u0e23\u0e31\u0e1a\u0e42\u0e14\u0e22\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e23\u0e31\u0e1a \u0e40\u0e0a\u0e48\u0e19\u0e16\u0e49\u0e32\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e23\u0e31\u0e1a\u0e15\u0e31\u0e49\u0e07\u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e23\u0e31\u0e1a\u0e17\u0e35\u0e48 103MHz (\u0e02\u0e36\u0e49\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a\u0e27\u0e34\u0e18\u0e35\u0e01\u0e32\u0e23 Modulation)\u0e01\u0e47\u0e08\u0e30\u0e23\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e13\u0e17\u0e35\u0e48\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e2a\u0e39\u0e07\u0e41\u0e25\u0e30\u0e15\u0e48\u0e33\u0e01\u0e27\u0e48\u0e32\u0e04\u0e27\u0e32\u0e21\u0e16\u0e35\u0e48\u0e17\u0e35\u0e48\u0e15\u0e31\u0e49\u0e07\u0e44\u0e27\u0e49\u0e19\u0e34\u0e14\u0e2b\u0e19\u0e48\u0e2d\u0e22 \u0e21\u0e32\u0e01\u0e19\u0e49\u0e2d\u0e22\u0e41\u0e04\u0e48\u0e44\u0e2b\u0e19\u0e02\u0e36\u0e49\u0e19\u0e2d\u0e22\u0e39\u0e48\u0e01\u0e31\u0e1a\u0e27\u0e48\u0e32 Bandwidth \u0e40\u0e17\u0e48\u0e32\u0e44\u0e2b\u0e23\u0e48","title":"Wireless Preliminary"},{"location":"wireless/#wireless-network","text":"Personal Area Network (PAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e43\u0e01\u0e25\u0e49\u0e04\u0e19 Local Area Network (LAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e41\u0e04\u0e48\u0e43\u0e19\u0e2d\u0e32\u0e04\u0e32\u0e23 Wide Area Network (EAN) \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e17\u0e35\u0e48\u0e2d\u0e22\u0e39\u0e48\u0e17\u0e31\u0e48\u0e27\u0e2d\u0e48\u0e30","title":"Wireless Network"},{"location":"wireless/#protocols","text":"International Organi z ation for Standardi z ation (ISO) \u0e44\u0e14\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14 Protocol for Protocols \u0e44\u0e27\u0e49\u0e40\u0e1b\u0e47\u0e19 Open Systems Interconnect \u0e2b\u0e23\u0e37\u0e2d OSI model OSI Model","title":"Protocols"},{"location":"wireless/#protocol-ieee-woring-groups","text":"IEEE \u0e04\u0e19\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e21\u0e32\u0e15\u0e23\u0e10\u0e32\u0e19\u0e43\u0e2b\u0e49\u0e01\u0e31\u0e1a protocol \u0e15\u0e48\u0e32\u0e07\u0e46\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a network \u0e42\u0e14\u0e22\u0e08\u0e30\u0e02\u0e36\u0e49\u0e19\u0e14\u0e49\u0e27\u0e22 802. IEEE Woring Group Description 802.3 Ethernet 802.11 Wireless LAN, including Wi-Fi 802.15 Wireless PAN 802.15.1 Bluetooth 802.15.3 High-rate wireless PAN 802.15.4 Low-rate wireless PAN, e.g. Zigbee","title":"Protocol - IEEE Woring groups"},{"location":"wireless/#bluetooth","text":"\u0e40\u0e1b\u0e47\u0e19 Digital Radio Protocol \u0e43\u0e0a\u0e49\u0e43\u0e19 Network \u0e41\u0e1a\u0e1a PAN \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e01\u0e31\u0e1a\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c","title":"Bluetooth"},{"location":"wireless/#bluetooth-characterisics","text":"Class Range Power 1 100 meters 100mW 2 10 meters 2.5mW 3 1 meters 1mW \u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c BT \u0e41\u0e15\u0e48\u0e25\u0e30\u0e15\u0e31\u0e27\u0e21\u0e35 Unique MAC Address (\u0e2b\u0e23\u0e2d\u0e27\u0e30!!) \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35 Phase \u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49 1. Discovery \u0e01\u0e47\u0e04\u0e37\u0e2d Broadcast \u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e17\u0e31\u0e49\u0e07\u0e0a\u0e37\u0e48\u0e2d\u0e41\u0e25\u0e30 MAC Address 1. Pairing \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e17\u0e31\u0e49\u0e07 Slave \u0e41\u0e25\u0e30 Master \u0e41\u0e25\u0e01\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e27\u0e48\u0e32\u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e07 1. Connecting \u0e01\u0e47\u0e04\u0e37\u0e2d Master \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e40\u0e1b\u0e34\u0e14\u0e08\u0e32\u0e01 Link \u0e17\u0e35\u0e48\u0e44\u0e14\u0e49 Pair \u0e01\u0e31\u0e19\u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27","title":"Bluetooth Characterisics"},{"location":"wireless/#rn-41-bluetooth-module-with-mbed","text":"\u0e43\u0e0a\u0e49\u0e42\u0e21\u0e14\u0e39\u0e25 RN-41 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Class 1 \u0e14\u0e49\u0e27\u0e22\u0e41\u0e25\u0e30\u0e01\u0e47\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Bluetooth \u0e02\u0e2d\u0e07 \u0e42\u0e19\u0e49\u0e15\u0e1a\u0e38\u0e4a\u0e15\u0e44\u0e14\u0e49\u0e40\u0e25\u0e22 \u0e2a\u0e48\u0e27\u0e19\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a MBED \u0e1c\u0e48\u0e32\u0e19 UART Serial \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e07\u0e31\u0e49\u0e19\u0e27\u0e34\u0e18\u0e35\u0e43\u0e0a\u0e49\u0e44\u0e21\u0e48\u0e15\u0e48\u0e32\u0e07\u0e2d\u0e30\u0e44\u0e23\u0e01\u0e31\u0e1a Serial \u0e40\u0e25\u0e22 Bluetooth Module Connection","title":"RN-41 Bluetooth Module with MBED"},{"location":"wireless/#zigbee","text":"\u0e43\u0e0a\u0e49 Standard IEEE 802.15.4 \u0e15\u0e31\u0e27\u0e19\u0e35\u0e49\u0e04\u0e25\u0e49\u0e32\u0e22 Bluetooth \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e21\u0e35\u0e01\u0e32\u0e23 Pair \u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e19\u0e41\u0e15\u0e48\u0e27\u0e48\u0e32\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32 \u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e44\u0e14\u0e49\u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32(\u0e21\u0e32\u0e01\u0e46) \u0e41\u0e25\u0e30\u0e01\u0e34\u0e19\u0e44\u0e1f\u0e19\u0e49\u0e2d\u0e22(\u0e19\u0e49\u0e2d\u0e22\u0e0a\u0e34\u0e1a\u0e2b\u0e32\u0e22) \u0e40\u0e1b\u0e49\u0e32\u0e2b\u0e21\u0e32\u0e22\u0e40\u0e02\u0e32\u0e04\u0e37\u0e2d\u0e16\u0e39\u0e01\u0e27\u0e48\u0e32 (\u0e2b\u0e23\u0e32\u0e32 \u0e41\u0e1e\u0e07\u0e2a\u0e31\u0e2a\u0e40\u0e25\u0e22) \u0e07\u0e48\u0e32\u0e22\u0e01\u0e27\u0e48\u0e32\u0e41\u0e25\u0e30\u0e21\u0e35 Overhead \u0e02\u0e2d\u0e07 Software \u0e19\u0e49\u0e2d\u0e22\u0e01\u0e27\u0e48\u0e32","title":"ZigBee"},{"location":"wireless/#zigbee-device-types","text":"End Device \u0e40\u0e1b\u0e47\u0e19\u0e2d\u0e38\u0e1b\u0e01\u0e23\u0e13\u0e4c\u0e1b\u0e25\u0e32\u0e22\u0e17\u0e32\u0e07 \u0e08\u0e30\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a\u0e41\u0e04\u0e48 Parent (\u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Router \u0e2b\u0e23\u0e37\u0e2d Coordinator) \u0e17\u0e35\u0e48\u0e15\u0e48\u0e2d\u0e2d\u0e22\u0e39\u0e48\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19 Router \u0e43\u0e0a\u0e49 route traffic \u0e43\u0e0a\u0e49\u0e2a\u0e48\u0e07\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e23\u0e30\u0e2b\u0e27\u0e48\u0e32\u0e07 End Device \u0e01\u0e31\u0e1a Coordinator \u0e44\u0e14\u0e49 Coordinator \u0e40\u0e1b\u0e47\u0e19\u0e04\u0e19\u0e04\u0e38\u0e21\u0e40\u0e04\u0e23\u0e37\u0e2d\u0e02\u0e48\u0e32\u0e22 \u0e01\u0e33\u0e2b\u0e19\u0e14 Characteristic \u0e02\u0e2d\u0e07 Network \u0e14\u0e49\u0e27\u0e22 \u0e44\u0e21\u0e48\u0e21\u0e35\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49","title":"Zigbee Device Types"},{"location":"wireless/#xbee-wireless-modules","text":"\u0e44\u0e2d\u0e1a\u0e2d\u0e23\u0e4c\u0e14\u0e1e\u0e27\u0e01\u0e19\u0e35\u0e49\u0e40\u0e1b\u0e47\u0e19\u0e02\u0e2d\u0e07 Digi International XBee Module \u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e04\u0e2d\u0e21\u0e44\u0e21\u0e48\u0e21\u0e35 Zigbee \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e25\u0e07\u0e2d\u0e31\u0e19\u0e02\u0e27\u0e32\u0e0a\u0e48\u0e27\u0e22 \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e15\u0e48\u0e2d Module Zigbee \u0e40\u0e02\u0e49\u0e32\u0e04\u0e2d\u0e21\u0e41\u0e25\u0e30\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21 XCTU \u0e40\u0e1e\u0e37\u0e48\u0e2d Config XBee Module XBee Module","title":"XBee Wireless Modules"},{"location":"wireless/#implementing-a-zigbee-link-mbed-to-mbed","text":"XBee Module with MBED \u0e15\u0e48\u0e2d\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bluetooth \u0e43\u0e0a\u0e49\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bluetooth \u0e40\u0e25\u0e22 (\u0e16\u0e49\u0e32\u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a\u0e04\u0e2d\u0e21) \u0e17\u0e35\u0e48\u0e40\u0e2b\u0e25\u0e37\u0e2d\u0e02\u0e2d\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15 \u0e0a\u0e48\u0e32\u0e07\u0e41\u0e21\u0e48\u0e21","title":"Implementing a Zigbee Link mbed to mbed"}]}